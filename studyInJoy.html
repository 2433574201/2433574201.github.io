<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<title>技能树</title>
</head>
<body>
<h1 align="center" class="root">
<a name="7ae479j639v2fa4gn29rui4sbi">技能树</a>
</h1>
<div align="center" class="globalOverview">
<img src="studyInJoy_files/images/%E6%8A%80%E8%83%BD%E6%A0%91.jpg"></div>
<h2 class="topic">
<a name="18982agqa7mg6r30168vthpdmc">java基础</a>
</h2>
<h3 class="topic">
<a name="6p5o3cfj3kdf6f4fp09rcqc7lp">&nbsp;基础知识</a>
</h3>
<h3 class="topic">
<a name="5v5ranob7bthv4ist97qk16mnn">&nbsp;java容器</a>
</h3>
<h3 class="topic">
<a name="3h31p2r2p1necoe37pdv27oc4n">&nbsp;&nbsp;collection</a>
</h3>
<h3 class="topic">
<a name="70a501gvv1klh49hi9kc11a96v">&nbsp;&nbsp;&nbsp;List</a>
</h3>
<h3 class="topic">
<a name="0iog856mhcipc2g5bagqvus5ui">&nbsp;&nbsp;&nbsp;&nbsp;ArrayList</a>
</h3>
<h3 class="topic">
<a name="0skpsupaj368icj5qcg4q5de4r">&nbsp;&nbsp;&nbsp;&nbsp;LinkedList</a>
</h3>
<h3 class="topic">
<a name="46cmg09beggs7fs07e2iskloq2">&nbsp;&nbsp;&nbsp;&nbsp;Vector</a>
</h3>
<h3 class="topic">
<a name="45f0m6q52fbms5cnighu05mvk2">&nbsp;&nbsp;&nbsp;Set</a>
</h3>
<h3 class="topic">
<a name="3ljs50v3na3od6ne3scofruq5g">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet</a>
</h3>
<h3 class="topic">
<a name="5tnc39u98279maq5e509mtoish">&nbsp;&nbsp;&nbsp;&nbsp;HashSet</a>
</h3>
<h3 class="topic">
<a name="4384h7rkl3ebvpovs8b37mj8ju">&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet</a>
</h3>
<h3 class="topic">
<a name="6r931e4tsode01h2u4j718i6hg">&nbsp;&nbsp;&nbsp;queue</a>
</h3>
<h3 class="topic">
<a name="2kdrr44e80vmq6ccha530jlfhb">&nbsp;&nbsp;&nbsp;&nbsp;LinkeList</a>
</h3>
<h3 class="topic">
<a name="4at4lh4ft772ng8agoti160hsp">&nbsp;&nbsp;&nbsp;&nbsp;PriorityQueue</a>
</h3>
<h3 class="topic">
<a name="5qn5tjboauc38bo81j36qhfq2s">&nbsp;&nbsp;map</a>
</h3>
<h3 class="topic">
<a name="4rlv5domh95fchig62a5iiqvhb">&nbsp;&nbsp;&nbsp;HashMap</a>
</h3>
<h3 class="topic">
<a name="55831apc1n88rmj8cak9j3ogvs">&nbsp;&nbsp;&nbsp;LinkedHashMap</a>
</h3>
<h3 class="topic">
<a name="1e0tsck8m85rachhhgvqgrtd9f">&nbsp;&nbsp;&nbsp;TreeMap</a>
</h3>
<h3 class="topic">
<a name="4bdgjd9p4rsai2begsjk37dsf5">&nbsp;&nbsp;&nbsp;HashTable</a>
</h3>
<h3 class="topic">
<a name="469vn90jorounck9tbrp62f9cb">&nbsp;&nbsp;迭代器</a>
</h3>
<h3 class="topic">
<a name="1qo4r11tcqcl0u3fqi18jbei8a">&nbsp;&nbsp;Collections</a>
</h3>
<h3 class="topic">
<a name="48ootdidhe4gh4ve1tr0hkutlo">&nbsp;java'IO</a>
</h3>
<h3 class="topic">
<a name="0np719ufaa2g2dp4brh29u1s1p">&nbsp;&nbsp;https://github.com/2433574201/JavaGuide/blob/master/docs/java/Java%20IO%E4%B8%8ENIO.md#%E4%B8%80-java-io%EF%BC%8C%E7%A1%AC%E9%AA%A8%E5%A4%B4%E4%B9%9F%E8%83%BD%E5%8F%98%E8%BD%AF</a>
</h3>
<h3 class="topic">
<a name="03si8k66pfq4m338cpod3dhm8f">&nbsp;&nbsp;磁盘操作</a>
</h3>
<h3 class="topic">
<a name="0k6quh0uhqn1nlenqm2us336em">&nbsp;&nbsp;&nbsp;File</a>
</h3>
<h3 class="topic">
<a name="6o53i78nffg4mupngf004mvd2g">&nbsp;&nbsp;&nbsp;&nbsp;权限查看</a>
</h3>
<h3 class="topic">
<a name="29h1cma7dud22es0i9ro068les">&nbsp;&nbsp;&nbsp;&nbsp;文件属性</a>
</h3>
<h3 class="topic">
<a name="2jmsnmrl4gg36da73ne1u9f2uj">&nbsp;&nbsp;&nbsp;&nbsp;各种管理</a>
</h3>
<h3 class="topic">
<a name="27l9glakei5mnm9aq776pnkp45">&nbsp;&nbsp;&nbsp;&nbsp;File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</a>
</h3>
<h3 class="topic">
<a name="4890uihpfousecj1trobl0ilhp">&nbsp;&nbsp;&nbsp;Files</a>
</h3>
<h3 class="topic">
<a name="225h8rjtatkpjjjb7v42q6d4d0">&nbsp;&nbsp;字节流</a>
</h3>
<h3 class="topic">
<a name="0pu4itmia85mcrpplnufqh18u0">&nbsp;&nbsp;&nbsp;InputStream</a>
</h3>
<h3 class="topic">
<a name="6gol2ef5bj0ut27pjdcjq2a9ob">&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream</a>
</h3>
<h3 class="topic">
<a name="7rhp9f85qdfot77ebjp26dutid">&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream</a>
</h3>
<h3 class="topic">
<a name="1gp99gvpbphvv06afh9gl73m5e">&nbsp;&nbsp;&nbsp;&nbsp;ByteArrayInputStream</a>
</h3>
<h3 class="topic">
<a name="5qvq6m0kchck22s1q6k5j68cr7">&nbsp;&nbsp;&nbsp;&nbsp;FilterInputStream</a>
</h3>
<h3 class="topic">
<a name="6j6tufg67vqescsg444sv5qs5r">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream</a>
</h3>
<h3 class="topic">
<a name="1hs4datb1h1dtbdbjjbmluedaa">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream</a>
</h3>
<h3 class="topic">
<a name="74qkn4qvo4rgniddon5oph34f0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;。。。</a>
</h3>
<h3 class="topic">
<a name="5g6rp1dssvghp41n4pq40klpmt">&nbsp;&nbsp;&nbsp;&nbsp;PipedInputStream</a>
</h3>
<h3 class="topic">
<a name="2uciqgc0of1n5q19o3chq5m2v9">&nbsp;&nbsp;&nbsp;OutputStream</a>
</h3>
<h3 class="topic">
<a name="50h9p21gb3ufppdb4m1hdiee49">&nbsp;&nbsp;&nbsp;&nbsp; FileOutputStream</a>
</h3>
<h3 class="topic">
<a name="4l1bo3hpdsv54cd2fk2bjgf3ka">&nbsp;&nbsp;&nbsp;&nbsp;FilterOutputStream</a>
</h3>
<h3 class="topic">
<a name="4633ng32gu5obuauhdvclcvoln">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedOutputStream</a>
</h3>
<h3 class="topic">
<a name="46hikvjcsq7c3q46h2k50h9ogo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream</a>
</h3>
<h3 class="topic">
<a name="0k753aisq9755gahkbufc1igvp">&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream</a>
</h3>
<h3 class="topic">
<a name="3o177ao75jrk4qvafto2am2m37">&nbsp;&nbsp;&nbsp;&nbsp;PipedOutputStream</a>
</h3>
<h3 class="topic">
<a name="23q40ag3j5g68vcpn46hji9gqc">&nbsp;&nbsp;&nbsp;&nbsp;ByteArrayOutputStream</a>
</h3>
<h3 class="topic">
<a name="0i98bbd4f99h0kk7ka1oue6aep">&nbsp;&nbsp;字符流</a>
</h3>
<h3 class="topic">
<a name="36su850rlsu4el5n2vj7v91bnq">&nbsp;&nbsp;&nbsp;Reader</a>
</h3>
<h3 class="topic">
<a name="4sv1pr99r1q03f7c471f578dqv">&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader</a>
</h3>
<h3 class="topic">
<a name="2td6qdpkomeob07c4kfc9ai233">&nbsp;&nbsp;&nbsp;&nbsp;FilterReader </a>
</h3>
<h3 class="topic">
<a name="7prk7b90moedkm8etqsp5pott8">&nbsp;&nbsp;&nbsp;&nbsp;InputStreamReader</a>
</h3>
<h3 class="topic">
<a name="23chsri2c0r03hk1a6mtbfojpt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileReader</a>
</h3>
<h3 class="topic">
<a name="785d08fds4mpqlfrmfmlueu5mo">&nbsp;&nbsp;&nbsp;&nbsp;PipedReader</a>
</h3>
<h3 class="topic">
<a name="62v18fcffn6ua4mghvcms3ebv9">&nbsp;&nbsp;&nbsp;&nbsp; StringReader</a>
</h3>
<h3 class="topic">
<a name="24kn4t76vqhk357gn3ufl39vkn">&nbsp;&nbsp;&nbsp;Writer</a>
</h3>
<h3 class="topic">
<a name="3etrhpjv4kafnq6md07m96mnbv">&nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter</a>
</h3>
<h3 class="topic">
<a name="3vhnob93doguqbocginf7j79l8">&nbsp;&nbsp;&nbsp;&nbsp;FilterWriter</a>
</h3>
<h3 class="topic">
<a name="6q85nfm3uk12fit1tkoleh789i">&nbsp;&nbsp;&nbsp;&nbsp;OutputStreamWriter </a>
</h3>
<h3 class="topic">
<a name="1j3uabkamn56lq35869qk40fe0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileWriter</a>
</h3>
<h3 class="topic">
<a name="4rjm4ggeqsgggl1mq9ku29k6d0">&nbsp;&nbsp;&nbsp;&nbsp;PipedWriter</a>
</h3>
<h3 class="topic">
<a name="1prorh9degnoq030jcgld1jd23">&nbsp;&nbsp;&nbsp;&nbsp;PrintWriter</a>
</h3>
<h3 class="topic">
<a name="773udlt9blj4nqb619tlu8a1lr">&nbsp;&nbsp;&nbsp;&nbsp;StringWriter</a>
</h3>
<h3 class="topic">
<a name="54ha9evvbtll07cefp6kchqoqg">&nbsp;&nbsp;转换流</a>
</h3>
<h3 class="topic">
<a name="2mq8fdoue803m93ncjerp1ju0r">&nbsp;&nbsp;缓冲流</a>
</h3>
<h3 class="topic">
<a name="0imamfp892f2la65elssnjclk2">&nbsp;&nbsp;打印流</a>
</h3>
<h3 class="topic">
<a name="5ffndti0vjgnaeobji5ukoj4m3">&nbsp;&nbsp;数据流</a>
</h3>
<h3 class="topic">
<a name="4msjevlsg2uc4iff7s9ag6613t">&nbsp;&nbsp;对象流</a>
</h3>
<h3 class="topic">
<a name="6i2ji95qn0g1p8odmqba0236a7">&nbsp;&nbsp;随机文件操作</a>
</h3>
<h3 class="topic">
<a name="1nfrvpu8eqvauhuinq6ufipdln">&nbsp;&nbsp;&nbsp;RandomAccessFile</a>
</h3>
<h3 class="topic">
<a name="6sg5t4sk1rodiarqv6g3i20pq0">&nbsp;&nbsp;&nbsp;&nbsp;一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</a>
</h3>
<h3 class="topic">
<a name="58u26vd6eti8g142cb7roh2tqk">&nbsp;&nbsp;NIO</a>
</h3>
<h3 class="topic">
<a name="2jsa28u903uk0nl57out3gk3st">&nbsp;&nbsp;&nbsp;http://ifeve.com/channels/</a>
</h3>
<h3 class="topic">
<a name="0s1sc4qhsms8293f2567u7avr7">&nbsp;&nbsp;&nbsp;简介</a>
</h3>
<h3 class="topic">
<a name="7v4a85c1cug0eik26pbl6q9i15">&nbsp;&nbsp;&nbsp;&nbsp;NIO1.4开始，可以替代IO，面向缓冲和通道，更加高效，非阻塞式IO，传统的IO是面向流的，阻塞的，单向的，NIO还多一个selector，通道是铁路，缓冲区是火车，双向的</a>
</h3>
<h3 class="topic">
<a name="1nl4mubivfmooueq6emmv7ijnj">&nbsp;&nbsp;&nbsp;缓冲区</a>
</h3>
<h3 class="topic">
<a name="2tprfrlplrmc7cd4giovjkq3ff">&nbsp;&nbsp;&nbsp;&nbsp;负责数据的存取，不同数据类型（除了布尔类型）有不同的缓冲区，实质上是数组，通过allocate()获取缓冲区</a>
</h3>
<h3 class="topic">
<a name="3f1admh2t6o2bdanme94vdo4bj">&nbsp;&nbsp;&nbsp;&nbsp;put(),flip()，rewind()切换状态,get(),clear()清空缓冲区，但是数据存在，处于被遗忘状态</a>
</h3>
<h3 class="topic">
<a name="3sa4bgq6ls73rj3l8l7rk3dke4">&nbsp;&nbsp;&nbsp;&nbsp;缓冲区四个核心属性</a>
</h3>
<h3 class="topic">
<a name="4c0ca12ok7nus0ebff4gk4c2dd">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int mark = -1;</a>
</h3>
<h3 class="topic">
<a name="1jth96efcrb92gmvia91pj299d">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark()记录当前position的位置，reset()恢复到mark的位置</a>
</h3>
<h3 class="topic">
<a name="01ie652v7o673ft64pv08fuc2d">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int position = 0;</a>
</h3>
<h3 class="topic">
<a name="4els0bb2ffceuq0mr6t8cuklbb">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正在操作的数据</a>
</h3>
<h3 class="topic">
<a name="75nh4civdvu3ugt4n1jc7vkg6t">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int limit;</a>
</h3>
<h3 class="topic">
<a name="0lvrfpgei4g74m2s95hpllg6tj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以操作的缓冲区大小</a>
</h3>
<h3 class="topic">
<a name="2jc5cvc3a7kb38l029q2l033aa">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    private int capacity;</a>
</h3>
<h3 class="topic">
<a name="44etc890e8ras5318lu522bm2c">&nbsp;&nbsp;&nbsp;&nbsp;ByteBuffer</a>
</h3>
<h3 class="topic">
<a name="55h4q252jjjpl1tf1cmg1a37d0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接缓冲区</a>
</h3>
<h3 class="topic">
<a name="5fdtpeg065a4ajpleckgprst4b">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocateDirect()，建立在OS的物理内存中，某些情况中可以提高效率,开销大，对数据的可操作的粒度大，不易控制</a>
</h3>
<h3 class="topic">
<a name="6eqif6jqsvs5947iv9fevb5jlf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非直接缓冲区</a>
</h3>
<h3 class="topic">
<a name="5d2puj4pcgfhdiqtsmbv3q9qbm">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过allocate()分配，将缓存建立在JVM的缓存中</a>
</h3>
<h3 class="topic">
<a name="0ivofns3pvtn39v5m9kr0l1doe">&nbsp;&nbsp;&nbsp;通道Channel</a>
</h3>
<h3 class="topic">
<a name="3djaf4kgdeqa70r8pvrnodb0bo">&nbsp;&nbsp;&nbsp;&nbsp;通道表示IO源于目的的连接，类似流，但是本身不能直接访问数据，只能与buffer进行交互</a>
</h3>
<h3 class="topic">
<a name="0k153ko182f8unaq0q6cgcratk">&nbsp;&nbsp;&nbsp;&nbsp;类型</a>
</h3>
<h3 class="topic">
<a name="7l0v7t42e4iefiqfncusqoe7m5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileChannel：从文件中读写数据；</a>
</h3>
<h3 class="topic">
<a name="7pq4n0s5f1p8rocv2krq63q72l">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramChannel：通过 UDP 读写网络中数据；</a>
</h3>
<h3 class="topic">
<a name="7a82asqbp2mhjqnokvct32cku8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SocketChannel：通过 TCP 读写网络中数据；</a>
</h3>
<h3 class="topic">
<a name="0cuhphl9c758833lncffau3fkj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.</a>
</h3>
<h3 class="topic">
<a name="5irtp2ojdoeacvmv3dcugnm2it">&nbsp;&nbsp;&nbsp;&nbsp;数据传输</a>
</h3>
<h3 class="topic">
<a name="2at0os6bef11u6lm6ttavuevb0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存映射文件（直接缓冲区）</a>
</h3>
<h3 class="topic">
<a name="25m77p52d4drent1vt7gd30kbq">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非直接缓冲区</a>
</h3>
<h3 class="topic">
<a name="5om60t7f4eekqg4vd1us4vbpsq">&nbsp;&nbsp;&nbsp;&nbsp;分散读取聚集写入</a>
</h3>
<h3 class="topic">
<a name="0fgi5fip6to7ioemi9trs5kpda">&nbsp;&nbsp;&nbsp;选择器Selector</a>
</h3>
<h3 class="topic">
<a name="7vgs7nkbedrrndakqt7ta04gev">&nbsp;&nbsp;&nbsp;&nbsp;要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</a>
</h3>
<h3 class="topic">
<a name="648in8urgfnlg0kohjvdh8opd7">&nbsp;&nbsp;&nbsp;&nbsp;与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</a>
</h3>
<h3 class="topic">
<a name="2vhu3sokkcuq82tgjlcu46el1o">&nbsp;&nbsp;AIO</a>
</h3>
<p class="labelsAndMarkers">
<img class="marker" src="studyInJoy_files/images/progress_start.png"></p>
<h3 class="topic">
<a name="6qrdsaajhrqmljlekl2okdo061">&nbsp;&nbsp;&nbsp;暂时不学</a>
</h3>
<h3 class="topic">
<a name="28va4pmgs7f3nllv2fkpgiu0ta">&nbsp;java异常</a>
</h3>
<h3 class="topic">
<a name="4bppisb9hc99k9dbobggigsoep">&nbsp;&nbsp;https://blog.csdn.net/michaelgo/article/details/82790253</a>
</h3>
<h3 class="topic">
<a name="1cfe8rrudoqq0gfaqko68296t9">&nbsp;&nbsp;https://www.cnblogs.com/skywang12345/p/3544168.html</a>
</h3>
<h3 class="topic">
<a name="002kn06jifctiniueds5bnlkrj">&nbsp;java泛型</a>
</h3>
<h3 class="topic">
<a name="1u1e9p1umo3v42fitp2nris66h">&nbsp;&nbsp;类型变量的限制</a>
</h3>
<h3 class="topic">
<a name="124uid3sg8o5a3sa9a023tue27">&nbsp;&nbsp;泛型代码与虚拟机</a>
</h3>
<h3 class="topic">
<a name="5f0h3esr32gk5sj66551v71an6">&nbsp;&nbsp;&nbsp;擦除类型变量出现问题，增加桥接方法保证多态性</a>
</h3>
<h3 class="topic">
<a name="1atluoitfmc4qk93f8dlproovn">&nbsp;&nbsp;约束与局限</a>
</h3>
<h3 class="topic">
<a name="5sspnqs8rs170frpc5ahpu5pk7">&nbsp;&nbsp;&nbsp;不能用基本类型</a>
</h3>
<h3 class="topic">
<a name="7k3r7fooaqvmo2r3fumdcqd12m">&nbsp;&nbsp;&nbsp;运行时类型查询只适用于原始类型</a>
</h3>
<h3 class="topic">
<a name="5k6ruefdrh5g88rvhl4jisrkrv">&nbsp;&nbsp;&nbsp;不能创建参数化类型的数组（可以用List代替数组存储，安全有效）</a>
</h3>
<h3 class="topic">
<a name="3klrcpo7csn96jed0iggnspkss">&nbsp;&nbsp;&nbsp;泛型类的静态上下文中类型变量无效</a>
</h3>
<h3 class="topic">
<a name="3il5ocpek5o0m7701962k60712">&nbsp;&nbsp;&nbsp;不能抛出或捕获泛型类的实例，泛型类继承Exception不合法，catch子句不能使用类型变量</a>
</h3>
<h3 class="topic">
<a name="4h5sksc0kjg5n3iv6rot5rqt8b">&nbsp;&nbsp;&nbsp;。。。</a>
</h3>
<h3 class="topic">
<a name="3t57a8i1kkq44f7m9brs9lo43k">&nbsp;&nbsp;通配符类型</a>
</h3>
<h3 class="topic">
<a name="7stuoq08u4b8p51ljrkt6foism">&nbsp;java代理</a>
</h3>
<h3 class="topic">
<a name="0jfcji01mpq5f8c81hb2m3eo06">&nbsp;&nbsp;静态代理</a>
</h3>
<h3 class="topic">
<a name="06vdt4s90cira9cn6pe18cjm07">&nbsp;&nbsp;&nbsp;1.主要业务接口</a>
</h3>
<h3 class="topic">
<a name="1g0t8r7mdcm6bifs60uupof3mk">&nbsp;&nbsp;&nbsp;2.业务功能实现接口的类</a>
</h3>
<h3 class="topic">
<a name="3u54m1bt15aer6om4doh562veq">&nbsp;&nbsp;&nbsp;3.实现接口的静态代理类，把实现接口的类注入到静态代理类，静态代理类调用业务类的方法重写接口的方法</a>
</h3>
<h3 class="topic">
<a name="00s3r8qirsia2p74k5ddmln9he">&nbsp;&nbsp;动态代理</a>
</h3>
<h3 class="topic">
<a name="3jj7dh4jlie50ientvu45n5tgo">&nbsp;&nbsp;&nbsp;1.实现InvocationHandler,将目标对象注入到代理对象中，利用反射完成代理</a>
</h3>
<h3 class="topic">
<a name="7n7qcgbcr9sgoas41suck2efki">&nbsp;&nbsp;&nbsp;从静态代理第二步开始</a>
</h3>
<h3 class="topic">
<a name="0hednn74pldmebl8aufibgbnmq">&nbsp;&nbsp;&nbsp;动态代理类实现InvocationHandler接口，注入业务类，Proxy.newProxyInstance返回代理类，重写invoke（）方法</a>
</h3>
<h3 class="topic">
<a name="4le5or39e31mip8s7mqrmtpeke">&nbsp;java反射</a>
</h3>
<p class="labelsAndMarkers">
<img class="marker" src="studyInJoy_files/images/progress_start.png"></p>
<h3 class="topic">
<a name="0g6nml8cd83onp4q8er8bm4go6">&nbsp;&nbsp;https://blog.csdn.net/lwl20140904/article/details/80163880</a>
</h3>
<h3 class="topic">
<a name="02u98l6ono4surdqlv4jjf94u0">&nbsp;&nbsp;使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）</a>
</h3>
<h3 class="topic">
<a name="0cn0mu49ecjvv82ln4nrqglcj4">&nbsp;&nbsp;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</a>
</h3>
<h3 class="topic">
<a name="5fb8auanifi1h3cri5puvprfqr">&nbsp;&nbsp;要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</a>
</h3>
<h3 class="topic">
<a name="458bbfevdmc0gj4e1ki3va9oq8">&nbsp;&nbsp;获取Class对象的三种方式</a>
</h3>
<h3 class="topic">
<a name="63bupaud284no6r17doqv6mlmo">&nbsp;&nbsp;&nbsp;1.1 Object &mdash;&mdash;&gt; getClass();</a>
</h3>
<h3 class="topic">
<a name="2b80ci6ap9gtui53bcnjsopdog">&nbsp;&nbsp;&nbsp;1.2 任何数据类型（包括基本数据类型）都有一个&ldquo;静态&rdquo;的class属性</a>
</h3>
<h3 class="topic">
<a name="6ilou337gbj72gtuvrpe6velam">&nbsp;&nbsp;&nbsp;1.3 通过Class类的静态方法：forName（String  className）(常用)</a>
</h3>
<h3 class="topic">
<a name="0io4pc4ngn75emh19f3lsr7or8">&nbsp;&nbsp;通过反射获取构造方法并使用：</a>
</h3>
<h3 class="topic">
<a name="02748h3u84vp637m3a3qg6mhff">&nbsp;&nbsp;&nbsp; 1).批量的方法： &#13;
 *          public Constructor[] getConstructors()：所有&rdquo;公有的&rdquo;构造方法 &#13;
            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) &#13;
      &#13;
 *      2).获取单个的方法，并调用： &#13;
 *          public Constructor getConstructor(Class&hellip; parameterTypes):获取单个的&rdquo;公有的&rdquo;构造方法： &#13;
 *          public Constructor getDeclaredConstructor(Class&hellip; parameterTypes):获取&rdquo;某个构造方法&rdquo;可以是私有的，或受保护、默认、公有； &#13;
 *       &#13;
 *          调用构造方法： &#13;
 *          Constructor&ndash;&gt;newInstance(Object&hellip; initargs) &#13;
 */  </a>
</h3>
<h3 class="topic">
<a name="278n0q25q773vd42u0b764uake">&nbsp;&nbsp;获取成员变量并调用</a>
</h3>
<h3 class="topic">
<a name="7aahl2g9n6i7vu30c5fvqp5cbp">&nbsp;&nbsp;&nbsp;1.批量的 &#13;
 *      1).Field[] getFields():获取所有的&rdquo;公有字段&rdquo; &#13;
 *      2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； &#13;
 * 2.获取单个的： &#13;
 *      1).public Field getField(String fieldName):获取某个&rdquo;公有的&rdquo;字段； &#13;
 *      2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) &#13;
 *  &#13;
 *   设置字段的值： &#13;
 *      Field &ndash;&gt; public void set(Object obj,Object value): &#13;
 *                  参数说明： &#13;
 *                  1.obj:要设置的字段所在的对象； &#13;
 *                  2.value:要为字段设置的值； &#13;
 *  &#13;
 */  </a>
</h3>
<h3 class="topic">
<a name="2au84pmefiblh42etc6v0gjsuq">&nbsp;&nbsp;获取成员方法并调用</a>
</h3>
<h3 class="topic">
<a name="2jr6ss8bdfabrnbuus557ar56r">&nbsp;&nbsp;&nbsp;* 1.批量的： &#13;
 *      public Method[] getMethods():获取所有&rdquo;公有方法&rdquo;；（包含了父类的方法也包含Object类） &#13;
 *      public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) &#13;
 * 2.获取单个的： &#13;
 *      public Method getMethod(String name,Class&lt;?&gt;&hellip; parameterTypes): &#13;
 *                  参数： &#13;
 *                      name : 方法名； &#13;
 *                      Class &hellip; : 形参的Class类型对象 &#13;
 *      public Method getDeclaredMethod(String name,Class&lt;?&gt;&hellip; parameterTypes) &#13;
 *  &#13;
 *   调用方法： &#13;
 *      Method &ndash;&gt; public Object invoke(Object obj,Object&hellip; args): &#13;
 *                  参数说明： &#13;
 *                  obj : 要调用方法的对象； &#13;
 *                  args:调用方式时所传递的实参； &#13;
 &#13;
): &#13;
 */  </a>
</h3>
<h3 class="topic">
<a name="7fni20o3eveuvipjfjekngdrrr">&nbsp;&nbsp;反射main方法</a>
</h3>
<h3 class="topic">
<a name="5sduunldueogf1tf6m3uqs7nkf">&nbsp;&nbsp;&nbsp;//1、获取Student对象的字节码  &#13;
            Class clazz = Class.forName(&rdquo;fanshe.main.Student&rdquo;);  &#13;
              &#13;
            //2、获取main方法  &#13;
             Method methodMain = clazz.getMethod(&rdquo;main&rdquo;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，  &#13;
            //3、调用main方法  &#13;
            // methodMain.invoke(null, new String[]{&ldquo;a&rdquo;,&rdquo;b&rdquo;,&rdquo;c&rdquo;});  &#13;
             //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数  &#13;
             //这里拆的时候将  new String[]{&ldquo;a&rdquo;,&rdquo;b&rdquo;,&rdquo;c&rdquo;} 拆成3个对象。。。所以需要将它强转。  &#13;
             methodMain.invoke(null, (Object)new String[]{&ldquo;a&rdquo;,&ldquo;b&rdquo;,&ldquo;c&rdquo;});//方式一  &#13;
            // methodMain.invoke(null, new Object[]{new String[]{&ldquo;a&rdquo;,&rdquo;b&rdquo;,&rdquo;c&rdquo;}});//方式二  </a>
</h3>
<h3 class="topic">
<a name="3s5iot1jg6ir2809j62ielgg9q">&nbsp;&nbsp;反射调用静态方法</a>
</h3>
<h3 class="topic">
<a name="62pah2n5i6sk7l44bo54sij2jp">&nbsp;&nbsp;&nbsp;只需要将invoke方法的第一个参数设为null即可！ </a>
</h3>
<h3 class="topic">
<a name="5o7amp5nmnu1hinnmnsneob0m1">&nbsp;&nbsp;反射方法的其它使用之&mdash;通过反射运行配置文件内容</a>
</h3>
<h3 class="topic">
<a name="2n34a7l73eh62gv1ft2j6o85in">&nbsp;&nbsp;反射方法的其它使用之&mdash;通过反射越过泛型检查，无视类型？</a>
</h3>
<h3 class="topic">
<a name="2pv72ntddmlipul0l5b6edi3e4">&nbsp;java并发编程</a>
</h3>
<h3 class="topic">
<a name="57do5jqcvljnkvjha8f62fsrlc">&nbsp;&nbsp;线程的含义</a>
</h3>
<h3 class="topic">
<a name="28skqmf3a88am9tbp4t1p9tuf0">&nbsp;&nbsp;线程的状态及转换</a>
</h3>
<h3 class="topic">
<a name="2t4lbfm9japhc6u9thumtcpoot">&nbsp;&nbsp;线程的创建方式</a>
</h3>
<h3 class="topic">
<a name="27g7a4l9533u4a8a5t0vaa7hi7">&nbsp;&nbsp;&nbsp;继承Thread类</a>
</h3>
<h3 class="topic">
<a name="1ao2nid48kbgikgkllt1k1e0kn">&nbsp;&nbsp;&nbsp;实现Runable接口</a>
</h3>
<h3 class="topic">
<a name="0kvg6ahekvsgavgquj8qs97s6c">&nbsp;&nbsp;&nbsp;实现CallAble接口</a>
</h3>
<h3 class="topic">
<a name="34npicvemp8llulshqmpeq0s1o">&nbsp;&nbsp;线程同步</a>
</h3>
<h3 class="topic">
<a name="39vot33kecggpj3sv2gkqnkmdp">&nbsp;&nbsp;&nbsp;sychonized关键字及其原理</a>
</h3>
<h3 class="topic">
<a name="407fcnq2r6gla44dt5vp7muevm">&nbsp;&nbsp;&nbsp;&nbsp;既保证可见性，有保证原子性</a>
</h3>
<h3 class="topic">
<a name="29so2rdud5emujtcbdjqdtgih2">&nbsp;&nbsp;&nbsp;volatile关键字及其原理</a>
</h3>
<h3 class="topic">
<a name="6m78u10od5ctplviuj216eulf6">&nbsp;&nbsp;&nbsp;&nbsp;保证内存可见性，效率高，但是不保证原子型</a>
</h3>
<h3 class="topic">
<a name="14gb0ssesv4tcajpoiqncl35v2">&nbsp;&nbsp;CAS算法</a>
</h3>
<h3 class="topic">
<a name="3onnm9cflrehjj37e92fd1433q">&nbsp;&nbsp;线程通信</a>
</h3>
<h3 class="topic">
<a name="66aa702816j4gg3lpa5shtsjs5">&nbsp;&nbsp;&nbsp;通信方式</a>
</h3>
<h3 class="topic">
<a name="3li6j1f22fju1jbaqmf828dfge">&nbsp;&nbsp;&nbsp;虚假唤醒</a>
</h3>
<h3 class="topic">
<a name="7n3lelbuohldopmttp4k55chcc">&nbsp;&nbsp;锁</a>
</h3>
<h3 class="topic">
<a name="5uoh0qhfflu3v25vii49aspkvc">&nbsp;&nbsp;&nbsp;Lock</a>
</h3>
<h3 class="topic">
<a name="5r671pmbd7ht442mvkav2fesll">&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock</a>
</h3>
<h3 class="topic">
<a name="4k7e3iq5mso5ptdln23mpabvq1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock</a>
</h3>
<h3 class="topic">
<a name="6pujbebgpqc2frniu3q7hkgr5u">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryLock</a>
</h3>
<h3 class="topic">
<a name="42c4ddnqvrfogpnahvranj0cc6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lockInterruptily可以被打断</a>
</h3>
<h3 class="topic">
<a name="1dpso2hn61l1k1g0u5j0687mop">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与sychonized相比，可以指定为公平锁</a>
</h3>
<h3 class="topic">
<a name="4gvidpug1hh9ubq04t4lkkim6g">&nbsp;&nbsp;&nbsp;&nbsp;ReentrantReadWriteLock</a>
</h3>
<h3 class="topic">
<a name="082hv4kn51bqd6cjohftoksket">&nbsp;&nbsp;&nbsp;&nbsp;StampedLock</a>
</h3>
<h3 class="topic">
<a name="68t6kamm1sdpj93jtsqeji8ur5">&nbsp;&nbsp;&nbsp;&nbsp;锁定代码运行出现异常，默认会释放锁，其他线程会进入继续执行上次中断处的代码，要注意这种情况，wait会释放锁，notify、sleep不会释放锁</a>
</h3>
<h3 class="topic">
<a name="54ivl17jpd3huics569gtg8gu6">&nbsp;&nbsp;&nbsp;Condition</a>
</h3>
<h3 class="topic">
<a name="4ruklff39uuemfce54olp69dhu">&nbsp;&nbsp;ThreadLocal线程局部变量：每个线程的都不是同一个，各自都有</a>
</h3>
<h3 class="topic">
<a name="133d4n4oefld3j21i8n8sp50jj">&nbsp;&nbsp;Semaphore （信号量）和CountDownLatch</a>
</h3>
<h3 class="topic">
<a name="1a2249crrrvu6rqg177urhu64i">&nbsp;&nbsp;6种线程池</a>
</h3>
<h3 class="topic">
<a name="776mcl20c6oc5srom4aa36s97n">&nbsp;&nbsp;&nbsp;Fixed</a>
</h3>
<h3 class="topic">
<a name="7hvrds71di14pa7c8aclaq8cb3">&nbsp;&nbsp;&nbsp;cache</a>
</h3>
<h3 class="topic">
<a name="6qv5ltdgbq3s83md1dpo8fpfcd">&nbsp;&nbsp;&nbsp;single</a>
</h3>
<h3 class="topic">
<a name="3m51l86alrnp4i3ga61r892s2n">&nbsp;&nbsp;&nbsp;workStealing</a>
</h3>
<h3 class="topic">
<a name="7ju6hsptljaafo88sv0u8rvpjj">&nbsp;&nbsp;&nbsp;forkjoin</a>
</h3>
<h3 class="topic">
<a name="3ufak15da348o01j0rc2o6lopc">&nbsp;&nbsp;&nbsp;scheduel</a>
</h3>
<h3 class="topic">
<a name="6dqufruvg2j8qvkhnvfauogvag">&nbsp;&nbsp;&nbsp;原理类</a>
</h3>
<h3 class="topic">
<a name="6rsopi4v0tlrnb8jh2tkn63gqb">&nbsp;&nbsp;&nbsp;&nbsp;ThreadPoolExecutor</a>
</h3>
<h3 class="topic">
<a name="5k1iticabt7ffasv9le7r7q77o">&nbsp;&nbsp;原子类</a>
</h3>
<h3 class="topic">
<a name="2gagemlnelndm7f6akcto9f70g">&nbsp;&nbsp;&nbsp;可以保证可见性</a>
</h3>
<h3 class="topic">
<a name="7k7f676sciomr61304tsavqgsc">&nbsp;&nbsp;&nbsp;效率比sychonized高</a>
</h3>
<h3 class="topic">
<a name="002geaa78b83lhuvcv1hqdsndr">&nbsp;&nbsp;JUC工具类</a>
</h3>
<h3 class="topic">
<a name="44u8u7g0k7b3nvcuu4lpodc12d">&nbsp;&nbsp;parallelStream</a>
</h3>
<h3 class="topic">
<a name="31e3li56ro4t2s9k3b8v32cru8">&nbsp;&nbsp;线程安全的容器</a>
</h3>
<h3 class="topic">
<a name="2f30a1saaovcdvev3g0v0d8bol">&nbsp;&nbsp;&nbsp;List</a>
</h3>
<h3 class="topic">
<a name="1ddgp5gc9ns4029tcflio0ihl5">&nbsp;&nbsp;&nbsp;&nbsp;CopyOnWriteArrayList(思考：迭代器如何做，保证线程安全？什么是弱一致性迭代器？）</a>
</h3>
<h3 class="topic">
<a name="2b5bdn4ihgkmtkf25dhqsarc54">&nbsp;&nbsp;&nbsp;Set</a>
</h3>
<h3 class="topic">
<a name="6ciopq9658gqvqbqa8db91noh5">&nbsp;&nbsp;&nbsp;&nbsp;CopyOnWriteArraySet</a>
</h3>
<h3 class="topic">
<a name="3nrccto04diaul6amedsmgv7r4">&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentSkipListSet</a>
</h3>
<h3 class="topic">
<a name="7ng6r215mkpq2d5oiresuujn2o">&nbsp;&nbsp;&nbsp;Queue</a>
</h3>
<h3 class="topic">
<a name="6iqpmblft98khss2fuo388fg9c">&nbsp;&nbsp;&nbsp;&nbsp;ArrayBlockingQueue\LinkedBlockingQueue\PriorityQueue</a>
</h3>
<h3 class="topic">
<a name="42tst3roct5b515mtk8j0jag6m">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DelayQueue</a>
</h3>
<h3 class="topic">
<a name="2ugcjogd7uf5rnfnu775u60t5c">&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentLinkedQueue</a>
</h3>
<h3 class="topic">
<a name="0je6shttroigu5rkve2al8h3u5">&nbsp;&nbsp;&nbsp;&nbsp;TransferQueue</a>
</h3>
<h3 class="topic">
<a name="712r8berqa49elvpquvr4p5224">&nbsp;&nbsp;&nbsp;&nbsp;LinkedBlockingDeque</a>
</h3>
<h3 class="topic">
<a name="249h6e8j2t82icau5fa1dga23k">&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentLinkedDeque</a>
</h3>
<h3 class="topic">
<a name="7s7sls3jgpt5qsc2g2dh3tbgg0">&nbsp;&nbsp;&nbsp;Map</a>
</h3>
<h3 class="topic">
<a name="5vsuaj7glfl64dp80iuta8iqkk">&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap //（https://www.cnblogs.com/huangjuncong/p/9478505.html）</a>
</h3>
<h3 class="topic">
<a name="1ir7o56v71568t09aqd84rm63v">&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentSkipListMap</a>
</h3>
<h3 class="topic">
<a name="5mudcioi2kkdn5n63gq4e8nh33">&nbsp;javaSocket编程</a>
</h3>
<p class="labelsAndMarkers">
<img class="marker" src="studyInJoy_files/images/progress_start.png"></p>
<h3 class="topic">
<a name="3v3detk88920vk9g5andropaok">&nbsp;&nbsp;TCP套接字编程</a>
</h3>
<h3 class="topic">
<a name="4cqf41c004liv0p9k59krngc1n">&nbsp;&nbsp;UDP套接字编程</a>
</h3>
<h3 class="topic">
<a name="2pofvk6rejhs86ee6ocf0ovnjc">&nbsp;正则表达式</a>
</h3>
<h3 class="topic">
<a name="3ss6tb4cns31qm6rtnmn8d3qtc">&nbsp;JVM</a>
</h3>
<h3 class="topic">
<a name="6mk1rchafaeth0mdjbnbrrirr7">&nbsp;&nbsp;运行时数据区域</a>
</h3>
<h3 class="topic">
<a name="1d523q0nrphdvr7arhr6cpj9gd">&nbsp;&nbsp;&nbsp;线程私有</a>
</h3>
<h3 class="topic">
<a name="1ejaiak4qs79282n6h8j6p901m">&nbsp;&nbsp;&nbsp;&nbsp;程序计数器</a>
</h3>
<h3 class="topic">
<a name="5i7mvn3p7lermun5k52o75e64n">&nbsp;&nbsp;&nbsp;&nbsp;虚拟机栈</a>
</h3>
<h3 class="topic">
<a name="55j9eab17nufta3pf7fftu3dih">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StackOverFlowError 和 OutOfMemoryError。</a>
</h3>
<h3 class="topic">
<a name="0do8dsbhl6m1r2s9kk1uk8p7sb">&nbsp;&nbsp;&nbsp;&nbsp;本地方法栈</a>
</h3>
<h3 class="topic">
<a name="3u6pbvb8i0sbefvibrgei42lej">&nbsp;&nbsp;&nbsp;线程共享</a>
</h3>
<h3 class="topic">
<a name="4pqcsdm3ap0668orttqglhtlmd">&nbsp;&nbsp;&nbsp;&nbsp;堆</a>
</h3>
<h3 class="topic">
<a name="60413n85pnhhbgaumkj32hrmtg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</a>
</h3>
<h3 class="topic">
<a name="1h1fbbsjbmtql8c5eh52inv46q">&nbsp;&nbsp;&nbsp;&nbsp;方法区</a>
</h3>
<h3 class="topic">
<a name="043tra3ba50n81gd1lqhjj0msc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</a>
</h3>
<h3 class="topic">
<a name="20c7unvtrfsreaecdqd7p0dqid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池</a>
</h3>
<h3 class="topic">
<a name="14jo5f3qpgoudj9i0pnsj1t152">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）&#13;
&#13;
既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。&#13;
&#13;
JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</a>
</h3>
<h3 class="topic">
<a name="0n622adng4klc03j25ndetjlob">&nbsp;&nbsp;&nbsp;&nbsp;直接内存（注意不属于运行时数据区域）</a>
</h3>
<h3 class="topic">
<a name="1pf9uqb8tbjug0igo7svq6hd3u">&nbsp;&nbsp;对象在内存的创建与访问</a>
</h3>
<h3 class="topic">
<a name="0krbg4040ndjdr6hpurvrumcu0">&nbsp;&nbsp;垃圾回收</a>
</h3>
<h3 class="topic">
<a name="47nui2eore8hr9ijpa77pihaua">&nbsp;&nbsp;&nbsp;对象已死吗？</a>
</h3>
<h3 class="topic">
<a name="3qa23295d1vpm1e5imf98js5f3">&nbsp;&nbsp;&nbsp;&nbsp;计数器</a>
</h3>
<h3 class="topic">
<a name="2a2r2bsi63i43500chcn9bem7b">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象循环引用问题</a>
</h3>
<h3 class="topic">
<a name="05blh49cbt2h7qdn7cajfv4ar4">&nbsp;&nbsp;&nbsp;&nbsp;可达性分析</a>
</h3>
<h3 class="topic">
<a name="6o4tumiolapjpfb4hahh7trenl">&nbsp;&nbsp;&nbsp;垃圾回收算法</a>
</h3>
<h3 class="topic">
<a name="4iprv9lj14s86pspfn5mkrpciu">&nbsp;&nbsp;&nbsp;&nbsp;标记清除</a>
</h3>
<h3 class="topic">
<a name="5k216h4h3lvilma0vqrmov13f5">&nbsp;&nbsp;&nbsp;&nbsp;复制算法</a>
</h3>
<h3 class="topic">
<a name="57c711nnurnl2ho8ftc46784bi">&nbsp;&nbsp;&nbsp;&nbsp;标记整理</a>
</h3>
<h3 class="topic">
<a name="6ah7oq6ct8fedjg2a44bkk1b4u">&nbsp;&nbsp;&nbsp;&nbsp;分代收集</a>
</h3>
<h3 class="topic">
<a name="5k22rn4pgu69o7fr3uqiojv467">&nbsp;&nbsp;内存分配与回收策略</a>
</h3>
<h3 class="topic">
<a name="0g8o4d112vhik8vrkercupmonj">&nbsp;&nbsp;字节码结构</a>
</h3>
<h3 class="topic">
<a name="1q8ihebovd2c58n7be817a58n4">&nbsp;&nbsp;类加载机制</a>
</h3>
<p class="labelsAndMarkers">
<img class="marker" src="studyInJoy_files/images/progress_start.png"></p>
<h3 class="topic">
<a name="4of26notojet92f5bc9h3ehi0f">&nbsp;&nbsp;&nbsp;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类的加载机制。</a>
</h3>
<h3 class="topic">
<a name="744s4q8jm34emn2bg5o0s6i9tb">&nbsp;&nbsp;&nbsp;加载（Loading）：按照虚拟机规范，有且只有以下四种情况下必须立即对类进行&ldquo;初始化&rdquo;：&#13;
遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先出发其初始化。生成这4条指令的典型场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法的时候&#13;
使用 java.lang.reflect 包的方法对类进行反射调用的时候&#13;
当初始化一个类时，如果发现它的父类还没有进行初始化，则需要先触发其父类进行初始化&#13;
当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个类</a>
</h3>
<h3 class="topic">
<a name="340367jqi39m4ljk4bd6jnjss9">&nbsp;&nbsp;&nbsp;类的加载过程</a>
</h3>
<h3 class="topic">
<a name="1sc5pcgq3mfh3fqo74eu90aa66">&nbsp;&nbsp;&nbsp;&nbsp;加载</a>
</h3>
<h3 class="topic">
<a name="7nmj7r1macoihi50jna0k3s7ak">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一个类的全限定名来获取定义这个类对应的二进制字节流</a>
</h3>
<h3 class="topic">
<a name="77el7ck61mcq6l0tqtob2hqsi1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将这个类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构</a>
</h3>
<h3 class="topic">
<a name="6ck4dq05vif0n93u58srl2dm8h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区这些数据的访问入口。</a>
</h3>
<h3 class="topic">
<a name="7vc5c3cbsthepgdjv1ptad29dl">&nbsp;&nbsp;&nbsp;&nbsp;验证</a>
</h3>
<h3 class="topic">
<a name="5rrqvg3v82um4keudctqobc85g">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件格式验证，验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理。</a>
</h3>
<h3 class="topic">
<a name="2qp0pkfm8ij44nphqlsgnrk92d">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元数据验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范要求。</a>
</h3>
<h3 class="topic">
<a name="54q256c7lv9dl4np4bac6ain81">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节码验证，主要工作是进行数据流和控制流分析，保证被校验类的方法不会危害到虚拟机的安全。</a>
</h3>
<h3 class="topic">
<a name="79t1i8mj971aensvn715b1bj3j">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;符号引用验证，可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。</a>
</h3>
<h3 class="topic">
<a name="3l049cgp2tgql0rq74j8upk8li">&nbsp;&nbsp;&nbsp;&nbsp;准备</a>
</h3>
<h3 class="topic">
<a name="0o6vhjnspikho7hst5iu9e8r4u">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</a>
</h3>
<h3 class="topic">
<a name="4tvho4j8v30erjlc970pfio49i">&nbsp;&nbsp;&nbsp;&nbsp;解析</a>
</h3>
<h3 class="topic">
<a name="20bfe5vlm248jlbuig60a8d3om">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是虚拟机将常量池中的符号引用替换为直接引用的过程。</a>
</h3>
<h3 class="topic">
<a name="1evfku32i66s2m6pal4fns1k8p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用分别进行。</a>
</h3>
<h3 class="topic">
<a name="7ki5h45qovma82s9mjciio3542">&nbsp;&nbsp;&nbsp;&nbsp;初始化</a>
</h3>
<h3 class="topic">
<a name="6mfpa1gp22hptj7n61khjfpj4l">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真正开始执行类中定义的Java程序代码（或者说是字节码）。</a>
</h3>
<h3 class="topic">
<a name="034nhprd333auiti3ue32mepkg">&nbsp;&nbsp;&nbsp;类加载器</a>
</h3>
<h3 class="topic">
<a name="71acm2gd1d04puqhjjes66l5q0">&nbsp;&nbsp;&nbsp;&nbsp;类加载器虽然只用于实现类的加载动作，但是它的作用却远远不限于此，比较两个类是否&ldquo;相等&rdquo;，不仅仅要确认这两个类是否来源于同一个class文件，还需要加载这两个类的类加载器相同。</a>
</h3>
<h3 class="topic">
<a name="0koas6ikje7die0a96jd2e0eh6">&nbsp;&nbsp;&nbsp;&nbsp;双亲委派模型</a>
</h3>
<h3 class="topic">
<a name="7s3lo4e8sjptuiieanbu5n15ts">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟机的角度，只存在两种类加载器：</a>
</h3>
<h3 class="topic">
<a name="1qcm9155rv9gmceg1f21nnlkpt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机的一部分</a>
</h3>
<h3 class="topic">
<a name="3jm1o51rj979uveis13pvjghvu">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他类加载器，由Java语言实现，独立于虚拟机之外的，全部继承自抽象类 java.lang.ClassLoader</a>
</h3>
<h3 class="topic">
<a name="2jes0b6qj8j8oddcip4ofuflk8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发人员的角度，类加载器可以划分得更细致一些：</a>
</h3>
<h3 class="topic">
<a name="6ki28cqhl6shv4lnlt12e09i1d">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动类加载器（Bootstrap ClassLoader）：负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。</a>
</h3>
<h3 class="topic">
<a name="60eebufpjjg0d27pi9ea0fs8fh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展类加载器（Extension ClassLoader）：负责加载 &lt;JAVA_HOME&gt;\lib\ext 目录下的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</a>
</h3>
<h3 class="topic">
<a name="3kfc3fijt6m35norc76cje1mol">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应用程序类加载器（Application ClassLoader）：负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。</a>
</h3>
<h3 class="topic">
<a name="5da3sjkh61qdfo3f0epehiikln">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类加载器的双亲委派模型（Parent Delegation Model）：要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器。（⚠️，这里类加载器之间的父子关系一般不会以继承（Inheritance）来实现，而是使用组合（Composition）来复用父加载器的代码）。这种模型被广泛使用于几乎所有的Java程序中，但是它并不是一个强制性的约束，只是Java设计者推荐给开发者使用的一种类加载器实现方式。&#13;
&#13;
双亲委派模型的具体工作过程是：如果一个类收到了加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给他的父类加载器去完成，每一层次的加载类都是如此，因此所有的加载请求都会传递给最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围内找不到需要加载的类）时，子类才会尝试自己去加载。&#13;
&#13;
好处：java类随着它的类加载器一起具备了一种带有优先层级的层次关系，保证了Java程序的稳定运行。</a>
</h3>
<h3 class="topic">
<a name="0v1c01eutc42s3hjreicp43qga">&nbsp;&nbsp;高效并发</a>
</h3>
<h3 class="topic">
<a name="0u7qf950s9n8u3of9rl7f8297j">&nbsp;设计模式</a>
</h3>
<h2 class="topic">
<a name="4qtfahkvubjr1iosdaq2tot3uk">数据库原理</a>
</h2>
<h3 class="topic">
<a name="4cnnl964nn5qbf1gqpjtoporf4">&nbsp;关系型数据库</a>
</h3>
<h3 class="topic">
<a name="379jkfgfqse88klgdk5dapt68b">&nbsp;&nbsp;MySQL</a>
</h3>
<h3 class="topic">
<a name="5qhmun0jej52a8kkdkvdkkpedi">&nbsp;&nbsp;分页查询</a>
</h3>
<h3 class="topic">
<a name="5udomiu1jeq5rus98m9vvok98d">&nbsp;&nbsp;&nbsp;limit</a>
</h3>
<h3 class="topic">
<a name="4fol1gjvd9nfo4v34nf0j45vm9">&nbsp;&nbsp;&nbsp;对于大表，需要索引帮助</a>
</h3>
<h3 class="topic">
<a name="5kmm6ue63g8ui0jupop2e27dbc">&nbsp;&nbsp;事务，隔离级别，事务锁</a>
</h3>
<h3 class="topic">
<a name="4m34613dlva3t9hm83nk830uc2">&nbsp;&nbsp;&nbsp;spring对事务的支持</a>
</h3>
<h3 class="topic">
<a name="5c36ag2hr06195mt3lsu0lgbvg">&nbsp;&nbsp;&nbsp;事务特性ACID</a>
</h3>
<h3 class="topic">
<a name="2f98ragqsbe3cn8i3p4co9u06a">&nbsp;&nbsp;&nbsp;&nbsp;原子性</a>
</h3>
<h3 class="topic">
<a name="3bkful91nd5qqeklj15s0jo2lc">&nbsp;&nbsp;&nbsp;&nbsp;一致性</a>
</h3>
<h3 class="topic">
<a name="25nqlbub51uefulqec8knnpf45">&nbsp;&nbsp;&nbsp;&nbsp;隔离性</a>
</h3>
<h3 class="topic">
<a name="3otfgn9gjq140fn688s05t4tpe">&nbsp;&nbsp;&nbsp;&nbsp;持久性</a>
</h3>
<h3 class="topic">
<a name="24hhg9u5vm8ka88ff70g2bbfav">&nbsp;&nbsp;&nbsp;&nbsp;关系</a>
</h3>
<h3 class="topic">
<a name="4a3c0re4j58q2kn2u3fm00ha0r">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有满足一致性，事务的执行结果才是正确的。</a>
</h3>
<h3 class="topic">
<a name="4aeh1kvduk6d6c9qjoq1mke578">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</a>
</h3>
<h3 class="topic">
<a name="4hq0opob2f51b8iqemgu4t3r5h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</a>
</h3>
<h3 class="topic">
<a name="2oafc83k7jdoca8q3dkaqbejiu">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务满足持久化是为了能应对数据库崩溃的情况。</a>
</h3>
<h3 class="topic">
<a name="02gr2b6iu250ljgru9r9es7chr">&nbsp;&nbsp;&nbsp;事务安全隐患</a>
</h3>
<h3 class="topic">
<a name="55mjnndencjfhqev7o4ps9grrr">&nbsp;&nbsp;&nbsp;&nbsp;丢失修改</a>
</h3>
<h3 class="topic">
<a name="243pjja25r305o8erl8uce8n9a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。	例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</a>
</h3>
<h3 class="topic">
<a name="6d1hp9tq8qapssotv0uddkj3tk">&nbsp;&nbsp;&nbsp;&nbsp;脏读</a>
</h3>
<h3 class="topic">
<a name="0733rtcdgi5faknatgneqr6lls">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是&ldquo;脏数据&rdquo;，依据&ldquo;脏数据&rdquo;所做的操作可能是不正确的</a>
</h3>
<h3 class="topic">
<a name="3qck8jbg6hiad5ssg5c1q42iip">&nbsp;&nbsp;&nbsp;&nbsp;不可重读</a>
</h3>
<h3 class="topic">
<a name="07nm24t2mcvcmmqcsb605qhv5s">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</a>
</h3>
<h3 class="topic">
<a name="5e2a0d7c2l1n45gtb5dt09i3od">&nbsp;&nbsp;&nbsp;&nbsp;幻读</a>
</h3>
<h3 class="topic">
<a name="6s3ikid1ovqspj68gb5pkjvab1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</a>
</h3>
<h3 class="topic">
<a name="7mb2pkmp9ctr12sg2i1lv1bj8q">&nbsp;&nbsp;&nbsp;事务隔离级别</a>
</h3>
<h3 class="topic">
<a name="3p6m6607c4f15qiil0dlbceuio">&nbsp;&nbsp;&nbsp;&nbsp;读未提交</a>
</h3>
<h3 class="topic">
<a name="05g59umge02mf72j13uerc2kmt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</a>
</h3>
<h3 class="topic">
<a name="275hn3vtsnm266n3thak8hnrkc">&nbsp;&nbsp;&nbsp;&nbsp;读已提交</a>
</h3>
<h3 class="topic">
<a name="3f8873dn8n2lo48bud5bpk75km">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</a>
</h3>
<h3 class="topic">
<a name="11iucs1gabelgkcvfatc5hjhd9">&nbsp;&nbsp;&nbsp;&nbsp;可重读</a>
</h3>
<h3 class="topic">
<a name="7gfvgtfmeim1bbkplf1hp12tbg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</a>
</h3>
<h3 class="topic">
<a name="2qku03jm6bk8mde5r0oiuhpfeq">&nbsp;&nbsp;&nbsp;&nbsp;串行化</a>
</h3>
<h3 class="topic">
<a name="736v04kqs03r528q8lck4m24la">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。需要加锁实现</a>
</h3>
<h3 class="topic">
<a name="3b9pp4kucti45hupe5n22k93oa">&nbsp;&nbsp;&nbsp;锁</a>
</h3>
<h3 class="topic">
<a name="4bblt2hut15s36mlc1r5bes1nm">&nbsp;&nbsp;&nbsp;&nbsp;悲观锁</a>
</h3>
<h3 class="topic">
<a name="65qihh6qouc8uten0nml6ov9i1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的关系数据库里用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</a>
</h3>
<h3 class="topic">
<a name="39put5fcnl9b6afu9etspk2vqp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按使用性质划分</a>
</h3>
<h3 class="topic">
<a name="135rf1qoilk9hefnnd0gonib64">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共享锁</a>
</h3>
<h3 class="topic">
<a name="62ahplj36rf4sdjhhv1538c725">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S锁，也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源</a>
</h3>
<h3 class="topic">
<a name="78d560g5rjccsd8u5eu2rsn2ik">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 多个事务可封锁同一个共享页； </a>
</h3>
<h3 class="topic">
<a name="63lqd9s7p8a170qqfvh2gld0k9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 任何事务都不能修改该页； </a>
</h3>
<h3 class="topic">
<a name="3dpulu1dudqcu4krgv4eo1p46e">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 通常是该页被读取完毕，S锁立即被释放。</a>
</h3>
<h3 class="topic">
<a name="01mdbqur6rfhr659r6d4gu4vbj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排他锁</a>
</h3>
<h3 class="topic">
<a name="1fmttfvqfh2a8i26kvvae8hto1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X锁，也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。</a>
</h3>
<h3 class="topic">
<a name="1rmbuav1qqvmdk5pia882nap6a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 仅允许一个事务封锁此页； </a>
</h3>
<h3 class="topic">
<a name="32107hius7dtv4kui3q5oqsiag">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 其他任何事务必须等到X锁被释放才能对该页进行访问； </a>
</h3>
<h3 class="topic">
<a name="2lgr5bnp4s06naq9n1aefctln1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. X锁一直到事务结束才能被释放。</a>
</h3>
<h3 class="topic">
<a name="4o44rbt74vcq1jqmgrbv3tf046">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select * from ad_plan for update;</a>
</h3>
<h3 class="topic">
<a name="1ua47cns535tv5nq38su8ta77c">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新锁</a>
</h3>
<h3 class="topic">
<a name="5c0viff2pv2rhf2fobnkani3al">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U锁，在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。</a>
</h3>
<h3 class="topic">
<a name="3gvcmmeejj30nuft6j6dbada88">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为当使用共享锁时，修改数据的操作分为两步： </a>
</h3>
<h3 class="topic">
<a name="63kg7ul9lomr6an6m91fm7d988">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 首先获得一个共享锁，读取数据， </a>
</h3>
<h3 class="topic">
<a name="3emphn8lgfo34bjic06s3o16j1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 然后将共享锁升级为排他锁，再执行修改操作。 </a>
</h3>
<h3 class="topic">
<a name="211optlbvv97o40a04ocb1so9p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样如果有两个或多个事务同时对一个事务申请了共享锁，在修改数据时，这些事务都要将共享锁升级为排他锁。这时，这些事务都不会释放共享锁，而是一直等待对方释放，这样就造成了死锁。 </a>
</h3>
<h3 class="topic">
<a name="3r6c9tt1q3l87iga863tt6330k">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数据在修改前直接申请更新锁，在数据修改时再升级为排他锁，就可以避免死锁。</a>
</h3>
<h3 class="topic">
<a name="37h1vst4q384enccdckmdem71f">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁； </a>
</h3>
<h3 class="topic">
<a name="0qcjujij6nuiea89e7enu07lq8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 当被读取的页要被更新时，则升级为X锁； </a>
</h3>
<h3 class="topic">
<a name="0g73mp7v221mgrrqfjmbatfcmf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. U锁一直到事务结束时才能被释放。</a>
</h3>
<h3 class="topic">
<a name="67o2ki78ili2k9dsp5bvjh6s6o">&nbsp;&nbsp;&nbsp;&nbsp;乐观锁</a>
</h3>
<h3 class="topic">
<a name="46osbph9dnab7a2cm1m984b8po">&nbsp;&nbsp;视图</a>
</h3>
<h3 class="topic">
<a name="1r1gudrhqt73c65mn27mqcl11t">&nbsp;&nbsp;&nbsp;视图介绍</a>
</h3>
<h3 class="topic">
<a name="1uidverebp1ht1e97nlvsmkmp9">&nbsp;&nbsp;&nbsp;&nbsp;是从一个或多个表导出的虚拟的表，其内容由查询定义。具有普通表的结构，但是不实现数据存储。</a>
</h3>
<h3 class="topic">
<a name="23ncukeculh9sepaistdn8nk2p">&nbsp;&nbsp;&nbsp;视图的创建</a>
</h3>
<h3 class="topic">
<a name="7ger9ifnl2k549va0n6ncdt9qo">&nbsp;&nbsp;&nbsp;视图的修改</a>
</h3>
<h3 class="topic">
<a name="5chk17146at35qh4o90brjcha0">&nbsp;&nbsp;&nbsp;&nbsp;简单视图：数据来源于一张表，不包含函数以及进行分组，可以进行DML操作，操作会改变基表</a>
</h3>
<h3 class="topic">
<a name="50jdrfhngu1dfsm4c86q5g7pcp">&nbsp;&nbsp;&nbsp;&nbsp;复杂视图：数据来源于多个表，包含函数以及分组，不可以进行DML操作</a>
</h3>
<h3 class="topic">
<a name="28ln3ie07nr9li5ij8vo43sck3">&nbsp;&nbsp;&nbsp;视图的查看和删除</a>
</h3>
<h3 class="topic">
<a name="6qgkpqd8mg65atihu6iaagrd1g">&nbsp;&nbsp;&nbsp;视图与表的区别</a>
</h3>
<h3 class="topic">
<a name="7stp3fdni9o8e46r7rjlb555qa">&nbsp;&nbsp;&nbsp;视图的作用</a>
</h3>
<h3 class="topic">
<a name="741a5p30ptscb7umpl0r853phn">&nbsp;&nbsp;&nbsp;&nbsp;（1）简化了操作，把经常使用的数据定义为视图</a>
</h3>
<h3 class="topic">
<a name="6eehcs3h21qq4remhih1fc2ieb">&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;我们在使用查询时，在很多时候我们要使用聚合函数，同时还要 显示其它字段的信息，可能还会需要关联到其它表，这时写的语句可能会很长，如果这个动作频繁发生的话，我们可以创建视图，这以后，我们只需要select * from view就可以啦，这样很方便。</a>
</h3>
<h3 class="topic">
<a name="6aiduep4b3qo93hak9i6upvssd">&nbsp;&nbsp;&nbsp;&nbsp;（2）安全性，用户只能查询和修改能看到的数据</a>
</h3>
<h3 class="topic">
<a name="36v7ifub6drj2ov2j27bled66i">&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以将基表中重要的字段信息，可以不通过视图给用户，视图是动态的数据的集合，数据是随着基表的更新而更新。同时，用户对视图不可以随意的更改和删除，可以保证数据的安全性。</a>
</h3>
<h3 class="topic">
<a name="6i9pjk1b8hdo9omlmunnbdfd5i">&nbsp;&nbsp;&nbsp;&nbsp;（3）逻辑上的独立性，屏蔽了真实表的结构带来的影响</a>
</h3>
<h3 class="topic">
<a name="374mh3h0fjor1bu1s06vim99uq">&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。</a>
</h3>
<h3 class="topic">
<a name="6rg7ejucjuill5h9gm16r6jigc">&nbsp;&nbsp;&nbsp;视图的缺点</a>
</h3>
<h3 class="topic">
<a name="0juv2b8sis28iet91cj91s6qqv">&nbsp;&nbsp;&nbsp;&nbsp;（1）性能差</a>
</h3>
<h3 class="topic">
<a name="0bq8gkp2lf4ot669nulsfguii7">&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;数据库必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</a>
</h3>
<h3 class="topic">
<a name="7bfrogfqnkb510acdo7ksn34i2">&nbsp;&nbsp;&nbsp;&nbsp;（2）修改限制</a>
</h3>
<h3 class="topic">
<a name="6gmkavr1rbhkfhq5kn497rckm2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 若视图是由两个以上基本表导出的，则此视图不允许更新。</a>
</h3>
<h3 class="topic">
<a name="62v0hun8dj69oigl8nm5gpqu68">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</a>
</h3>
<h3 class="topic">
<a name="1me9hglgbagounkmcvke9j5l00">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 若视图的字段来自集函数，则此视图不允许更新。</a>
</h3>
<h3 class="topic">
<a name="72cc99u3bpidhtgi6lg69ib36m">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 若视图定义中含有GROUP BY子句，则此视图不允许更新。</a>
</h3>
<h3 class="topic">
<a name="348a2vng29o5aom47nrl2b2lvq">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 若视图定义中含有DISTINCT短语，则此视图不允许更新。</a>
</h3>
<h3 class="topic">
<a name="5rllu079spm5ce0keinou4t2a5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</a>
</h3>
<h3 class="topic">
<a name="6cv48ul8klj6sqgngtud2jbjff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7. 一个不允许更新的视图上定义的视图也不允许更新。</a>
</h3>
<h3 class="topic">
<a name="1tvvvko8rd012bnir28msg1def">&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。</a>
</h3>
<h3 class="topic">
<a name="15u3bjbe7ah5c9j8o23a5j8t8o">&nbsp;&nbsp;数据库连接池</a>
</h3>
<h3 class="topic">
<a name="4e05andfpom43ra7n2kq1ua3su">&nbsp;&nbsp;表连接</a>
</h3>
<h3 class="topic">
<a name="32dfvl4ejb0hrtn9prfsnn0c8g">&nbsp;&nbsp;&nbsp;内连接</a>
</h3>
<h3 class="topic">
<a name="41nm5p1c4guboptmksntrqs44d">&nbsp;&nbsp;&nbsp;&nbsp;等值连接</a>
</h3>
<h3 class="topic">
<a name="196i1r6eg3uqc68v8lb2vbs551">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where条件是=</a>
</h3>
<h3 class="topic">
<a name="7hr960rrepl2bf9hqblk8i7iom">&nbsp;&nbsp;&nbsp;&nbsp;非等值连接</a>
</h3>
<h3 class="topic">
<a name="6scmnbcmc6ea1e9qbe1qd135jf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where条件是非=</a>
</h3>
<h3 class="topic">
<a name="26n4hm6ie1l1rmd6a1jo59ojbf">&nbsp;&nbsp;&nbsp;&nbsp;自连接</a>
</h3>
<h3 class="topic">
<a name="0e5dli6lfu3363p5irftq7ams2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质上就是等值连接，只不过是自己和自己连接</a>
</h3>
<h3 class="topic">
<a name="5pcpfk734j32f5c5nqhl3kchb4">&nbsp;&nbsp;&nbsp;外连接</a>
</h3>
<h3 class="topic">
<a name="00s9s1a3v9je8l4co3h9g266lj">&nbsp;&nbsp;&nbsp;&nbsp;左外连接</a>
</h3>
<h3 class="topic">
<a name="5m4pvdodoflsi9t65lacnvrh4n">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以左表为主表，不匹配的显示null</a>
</h3>
<h3 class="topic">
<a name="1o3gtglem3bsuthh34joeek35o">&nbsp;&nbsp;&nbsp;&nbsp;右外连接</a>
</h3>
<h3 class="topic">
<a name="41sv4qaqut9g9djad9dir5i1af">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以右表为主表，不匹配的显示null</a>
</h3>
<h3 class="topic">
<a name="08ghh8r0r11ave4htosg7m5n54">&nbsp;&nbsp;&nbsp;&nbsp;全外连接</a>
</h3>
<h3 class="topic">
<a name="5hp03mvm56a7jtkimkcso6nrt5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。  </a>
</h3>
<h3 class="topic">
<a name="7bteoqs7pnfjegls56b3eb8d9p">&nbsp;&nbsp;&nbsp;交叉连接</a>
</h3>
<h3 class="topic">
<a name="22fmpogc2ps1j78fmd0hp32rtt">&nbsp;&nbsp;&nbsp;&nbsp;交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。 </a>
</h3>
<h3 class="topic">
<a name="600922lcqur7pqqdgmpt74mhqj">&nbsp;&nbsp;索引</a>
</h3>
<h3 class="topic">
<a name="4oator104mo1ud8p284l7emnt2">&nbsp;&nbsp;&nbsp;索引概念</a>
</h3>
<h3 class="topic">
<a name="2501jkeaffn4tq85fig9r2mh0q">&nbsp;&nbsp;&nbsp;&nbsp;官方对索引的定义：是帮助mySQL高效获取数据的数据结构</a>
</h3>
<h3 class="topic">
<a name="5vieue9caf9n9ljei587rkd0sn">&nbsp;&nbsp;&nbsp;&nbsp;简单理解就是排好序快速查找数据结构</a>
</h3>
<h3 class="topic">
<a name="28ptkj59r1cfa6tgput3tn4lpe">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用数据</a>
</h3>
<h3 class="topic">
<a name="7cib0huk8frcd0tvegltlf672k">&nbsp;&nbsp;&nbsp;&nbsp;索引本身也很大，不可能全部存在内存中，常常以索引文件存储在磁盘中</a>
</h3>
<h3 class="topic">
<a name="23027oavhq338u73060iah90ne">&nbsp;&nbsp;&nbsp;索引优势劣势</a>
</h3>
<h3 class="topic">
<a name="3npamn89ua0rt9371hha2pbkh4">&nbsp;&nbsp;&nbsp;&nbsp;优势</a>
</h3>
<h3 class="topic">
<a name="6m4ii8m1f32f1t5io2n7l9db6t">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提高数据的检索效率，降低数据库的IO成本</a>
</h3>
<h3 class="topic">
<a name="2koaskdvi4b7kfufu64hu0flcr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;降低数据的排序的成本，降低CPU的消耗</a>
</h3>
<h3 class="topic">
<a name="2r7ug7jrm0v18fsfigecbqdu07">&nbsp;&nbsp;&nbsp;&nbsp;劣势</a>
</h3>
<h3 class="topic">
<a name="0hs1bhurtq9p83f9ci1npi8ea0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上索引也是表，该表保存了主键和索引字段，并指向实体表的记录，所以会占用空间</a>
</h3>
<h3 class="topic">
<a name="02ra2862lpqh16jeb09d6pb6bq">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然会提高检索效率，但是降低对表的更新速度，因为也要维护对应的索引信息</a>
</h3>
<h3 class="topic">
<a name="1hd0n52iu7bndj280gpbvph7gr">&nbsp;&nbsp;&nbsp;索引分类</a>
</h3>
<h3 class="topic">
<a name="7lfippdquo1p0om2n44bdm346g">&nbsp;&nbsp;&nbsp;&nbsp;单值索引</a>
</h3>
<h3 class="topic">
<a name="23add5el279ndh38c0bpurff04">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单个列</a>
</h3>
<h3 class="topic">
<a name="7m26n5ucc6sfr9l2n4rrnp8o2f">&nbsp;&nbsp;&nbsp;&nbsp;唯一索引</a>
</h3>
<h3 class="topic">
<a name="56tk2bli47es9g746sbu12c1kg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引列的值必须唯一，允许为空</a>
</h3>
<h3 class="topic">
<a name="7l7ee7vjtnpjsdtnueh7a7sd9d">&nbsp;&nbsp;&nbsp;&nbsp;复合索引</a>
</h3>
<h3 class="topic">
<a name="75aopv4a6hu7gtfqn94j3k9h8t">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引包括多个列</a>
</h3>
<h3 class="topic">
<a name="092v38s9j2pi1ft11cc59ik1ro">&nbsp;&nbsp;&nbsp;索引结构与检索原理</a>
</h3>
<h3 class="topic">
<a name="3kba7s95rtk4e36pt10v74oc7h">&nbsp;&nbsp;&nbsp;&nbsp;索引结构</a>
</h3>
<h3 class="topic">
<a name="191vliihp95toe6m0vtja4t3q6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BTree索引</a>
</h3>
<h3 class="topic">
<a name="011g1j4lts7j517nhbic3apnt4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B+树原理，叶子节点存数据，其他节点只管理查找的流程</a>
</h3>
<h3 class="topic">
<a name="3hphoo0npdjgjf3ng73p50m2fp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hash索引</a>
</h3>
<h3 class="topic">
<a name="2s4kmh4iibliapgsckmi2q5d8t">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全文索引</a>
</h3>
<h3 class="topic">
<a name="7179luc0cdifu07evv62i52250">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RTree索引</a>
</h3>
<h3 class="topic">
<a name="0f12liecfci16uvpvoko1udgln">&nbsp;&nbsp;&nbsp;适合创建索引的情况</a>
</h3>
<h3 class="topic">
<a name="1b4j5qf4rrlvu5vpcvmbu7fmvf">&nbsp;&nbsp;&nbsp;&nbsp;1.主键自动建立唯一索引</a>
</h3>
<h3 class="topic">
<a name="729dh50fujcpfnn7hu4ivi5pol">&nbsp;&nbsp;&nbsp;&nbsp;2.频繁作为查询条件的字段应该建立索引</a>
</h3>
<h3 class="topic">
<a name="4s3t0f0fq94at7qpbpkaifuokj">&nbsp;&nbsp;&nbsp;&nbsp;3.查询中与其他表关联的字段建立索引</a>
</h3>
<h3 class="topic">
<a name="7dm3uu296lp33rr975526schcs">&nbsp;&nbsp;&nbsp;&nbsp;4.查询中排序的字段</a>
</h3>
<h3 class="topic">
<a name="7ffj6bs6rdlnn4jjlfusfithu3">&nbsp;&nbsp;&nbsp;&nbsp;5.查询中分组或者统计的字段</a>
</h3>
<h3 class="topic">
<a name="1hf4g2cojbfjmt127ucp5msl08">&nbsp;&nbsp;&nbsp;不适合创建索引的情况</a>
</h3>
<h3 class="topic">
<a name="75ikiffgi5irfdm324amhgaco4">&nbsp;&nbsp;&nbsp;&nbsp;频繁更新的字段</a>
</h3>
<h3 class="topic">
<a name="5l1balrvvb80qgbibk0d0nk6hj">&nbsp;&nbsp;&nbsp;&nbsp;where条件里用不到的字段最好不要建立索引</a>
</h3>
<h3 class="topic">
<a name="4o15t8nrcu9penicu4rspobfpr">&nbsp;&nbsp;&nbsp;&nbsp;表比较小不要创建索引</a>
</h3>
<h3 class="topic">
<a name="5etva2m9sf2kelr17r9h1mlnh3">&nbsp;&nbsp;&nbsp;&nbsp;数据重复且分布平均的字段</a>
</h3>
<h3 class="topic">
<a name="0tvat0umqcb5q2ht8fnldiqhsv">&nbsp;&nbsp;&nbsp;索引优化</a>
</h3>
<h3 class="topic">
<a name="7nbumlb63fvtsrstnbglg9ksch">&nbsp;&nbsp;&nbsp;&nbsp;索引分析</a>
</h3>
<h3 class="topic">
<a name="6okkrccgl4rkdi0aubb4gue2d8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单表</a>
</h3>
<h3 class="topic">
<a name="082g1v8lml6lsmv8cn2uo77sej">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两表</a>
</h3>
<h3 class="topic">
<a name="2hj2fkmkbvf319p1kjbj8h1u2d">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三表</a>
</h3>
<h3 class="topic">
<a name="0332tm3qmra43h3mnmuvqn728d">&nbsp;&nbsp;&nbsp;&nbsp;索引失败</a>
</h3>
<h3 class="topic">
<a name="3qc6tekuuqp7fuof21p9qiempd">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最左匹配原则</a>
</h3>
<h3 class="topic">
<a name="7lsbeidjfato9pm842pj1phe00">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若多值索引，要遵守带头大哥不能挂原则，且不能跳过索引中的列</a>
</h3>
<h3 class="topic">
<a name="49p5i5dho151si2htkj83kcg2c">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能在索引列上做计算，函数，类型转换操作</a>
</h3>
<h3 class="topic">
<a name="1h2qjfh009a4vbarimq3la6o8m">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储引擎不能使用索引中范围条件右边的列，这是个定理，不是原则</a>
</h3>
<h3 class="topic">
<a name="24gc6llvncabihdojstjhspoh1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽量使用覆盖索引，减少select *</a>
</h3>
<h3 class="topic">
<a name="6litpabhthq9s8gl6adbmsccbh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mySQL在使用不等于的时候无法使用索引</a>
</h3>
<h3 class="topic">
<a name="2s1l1ipe0mo141puibe9tf15ue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is null , is not null 也无法使用索引</a>
</h3>
<h3 class="topic">
<a name="4ldctq256c5oqjao68sqjsg0gj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;like用通配符会导致索引失效，开头，为全文检索，后面是range，不会失效</a>
</h3>
<h3 class="topic">
<a name="57vqp4fnso08p4dig4cio8d57g">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果必须这样，使用覆盖索引的方法解决</a>
</h3>
<h3 class="topic">
<a name="49hcn54r81l1eu05jtn2ij8og2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串不加单引号索引失败，违反第二条了</a>
</h3>
<h3 class="topic">
<a name="51covhgda3j1rems26g9ek3r56">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;少用or，可能违反第一条</a>
</h3>
<h3 class="topic">
<a name="29m4p5jqdij7a61a4c5iocjs3s">&nbsp;&nbsp;&nbsp;&nbsp;一般性建议</a>
</h3>
<h3 class="topic">
<a name="76nkng9j01qf52d573uj7rgjbe">&nbsp;&nbsp;&nbsp;&nbsp;注意：索引失效导致行锁转变为表锁，这是常见程序隐患，比如varchar类型不加单引号</a>
</h3>
<h3 class="topic">
<a name="7u7hm1p1ckp6pjmhrbq854brr1">&nbsp;&nbsp;数据库引擎</a>
</h3>
<h3 class="topic">
<a name="1uujehd32rrijiicv8q290p6vv">&nbsp;&nbsp;&nbsp;InnoDB</a>
</h3>
<h3 class="topic">
<a name="3l27kfvq07hnn9ehjb7e74ge4u">&nbsp;&nbsp;&nbsp;&nbsp;是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</a>
</h3>
<h3 class="topic">
<a name="7abkqedl9oask8qeg8p2qubsrc">&nbsp;&nbsp;&nbsp;&nbsp;实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</a>
</h3>
<h3 class="topic">
<a name="4disb12r7m9q3vn6742vhr8vna">&nbsp;&nbsp;&nbsp;&nbsp;主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</a>
</h3>
<h3 class="topic">
<a name="460ejo6n0cgcamkpfku1fhqet9">&nbsp;&nbsp;&nbsp;&nbsp;内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</a>
</h3>
<h3 class="topic">
<a name="15arpdvafg3va298a4qnkalnde">&nbsp;&nbsp;&nbsp;&nbsp;支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</a>
</h3>
<h3 class="topic">
<a name="3e6hhb4giu25kjp8pq7tcsivsa">&nbsp;&nbsp;&nbsp;MyISAM</a>
</h3>
<h3 class="topic">
<a name="4qeea6tr10scti384arqqnmkcu">&nbsp;&nbsp;&nbsp;&nbsp;设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</a>
</h3>
<h3 class="topic">
<a name="0ehgjq2siloll7jmlbi5r7jjra">&nbsp;&nbsp;&nbsp;&nbsp;提供了大量的特性，包括压缩表、空间数据索引等。</a>
</h3>
<h3 class="topic">
<a name="6felpsu5dd01e7kmvb9nfe92va">&nbsp;&nbsp;&nbsp;&nbsp;不支持事务。</a>
</h3>
<h3 class="topic">
<a name="0rqda8sc60env0q1parnobld03">&nbsp;&nbsp;&nbsp;&nbsp;不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</a>
</h3>
<h3 class="topic">
<a name="4hgm8e3bvs1d5hvac4lpglk795">&nbsp;&nbsp;&nbsp;&nbsp;可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</a>
</h3>
<h3 class="topic">
<a name="5lmqn9r5a4iu722sjvmsf8d7ft">&nbsp;&nbsp;&nbsp;&nbsp;如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</a>
</h3>
<h3 class="topic">
<a name="79lsi3ebrda69b77938hjlf27l">&nbsp;&nbsp;&nbsp;比较</a>
</h3>
<h3 class="topic">
<a name="46trb38mu16b1cfn7op639eevn">&nbsp;&nbsp;&nbsp;&nbsp;事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</a>
</h3>
<h3 class="topic">
<a name="36r0j6uj6m289ar0fc4sh0r11n">&nbsp;&nbsp;&nbsp;&nbsp;并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</a>
</h3>
<h3 class="topic">
<a name="5onkgrd9hnpijvq47v6frdb86r">&nbsp;&nbsp;&nbsp;&nbsp;外键：InnoDB 支持外键。</a>
</h3>
<h3 class="topic">
<a name="2er9dd2ujj3m0fenfm3tuueola">&nbsp;&nbsp;&nbsp;&nbsp;备份：InnoDB 支持在线热备份。</a>
</h3>
<h3 class="topic">
<a name="328hv54s7cns2e3dmh5vjiuilh">&nbsp;&nbsp;&nbsp;&nbsp;崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</a>
</h3>
<h3 class="topic">
<a name="0eam2f8fqo5odo9gfkuuanho44">&nbsp;&nbsp;&nbsp;&nbsp;其它特性：MyISAM 支持压缩表和空间数据索引。</a>
</h3>
<h3 class="topic">
<a name="7ig857bej3ec89cs596lpu4486">&nbsp;&nbsp;数据库分表</a>
</h3>
<h3 class="topic">
<a name="4mgjua67bkkuu0sieqoeltml54">&nbsp;&nbsp;&nbsp;水平切分</a>
</h3>
<h3 class="topic">
<a name="6l0ga1aolcm8m6pn9o7nk15n9r">&nbsp;&nbsp;&nbsp;&nbsp;水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</a>
</h3>
<h3 class="topic">
<a name="05nb8kdrtrph2hrlmb9qog4c9h">&nbsp;&nbsp;&nbsp;&nbsp;当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</a>
</h3>
<h3 class="topic">
<a name="20mutfm3688fvkncck18cjcr9a">&nbsp;&nbsp;&nbsp;&nbsp;拆分原则</a>
</h3>
<h3 class="topic">
<a name="6d3o6f0qhrker2pkjjhelcmkkg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，我们使用取模的方式来进行表的拆分;比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4</a>
</h3>
<h3 class="topic">
<a name="34fbu0dl0qg33nfdo1f5ipluv6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过用ID取模的方法把数据分散到四张表内Id%4+1 = [1,2,3,4]</a>
</h3>
<h3 class="topic">
<a name="34kjnqudabpm3q0gt8eni34631">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后查询,更新,删除也是通过取模的方法来查询</a>
</h3>
<h3 class="topic">
<a name="1d0bgleop79ihl0gjlvm55hvt9">&nbsp;&nbsp;&nbsp;&nbsp;Sharding 存在的问题</a>
</h3>
<h3 class="topic">
<a name="3373okcie5ag7e0t46ijb6erl3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 事务问题</a>
</h3>
<h3 class="topic">
<a name="7te4jdgd4ud4uu8kf8lfnl8pfo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用分布式事务来解决，比如 XA 接口。</a>
</h3>
<h3 class="topic">
<a name="45f7ltp9d5dofnu95dib7c6dpr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 连接</a>
</h3>
<h3 class="topic">
<a name="70p2g3md9bvu3ogv336a05dp1b">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</a>
</h3>
<h3 class="topic">
<a name="14a1a3i585tv0v5a9d948rkrc1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. ID 唯一性</a>
</h3>
<h3 class="topic">
<a name="4uehtpbcj6gkb848dri25g0mve">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用全局唯一 ID（GUID）</a>
</h3>
<h3 class="topic">
<a name="0k4mbloh5l2co87gc4tqvg1p2e">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为每个分片指定一个 ID 范围</a>
</h3>
<h3 class="topic">
<a name="6sd0h2m99b54uh2jev80pajdlh">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</a>
</h3>
<h3 class="topic">
<a name="6tbvugl25cpdntmn2dftu4fmtr">&nbsp;&nbsp;&nbsp;垂直切分</a>
</h3>
<h3 class="topic">
<a name="0u58ob5h2shicmnrvkoquk9rrd">&nbsp;&nbsp;&nbsp;&nbsp;垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表，垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关键起来即可;</a>
</h3>
<h3 class="topic">
<a name="69jt4as1a4k3u45ugk07dtmerj">&nbsp;&nbsp;主从复制</a>
</h3>
<h3 class="topic">
<a name="4prr8tscqm441o7jjvva95t2nt">&nbsp;&nbsp;&nbsp;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</a>
</h3>
<h3 class="topic">
<a name="62vbolb9e47i2vo4a0co3g9uts">&nbsp;&nbsp;&nbsp;binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</a>
</h3>
<h3 class="topic">
<a name="2nfiatmlff2grsaoauqd7ciqh4">&nbsp;&nbsp;&nbsp;I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</a>
</h3>
<h3 class="topic">
<a name="203v598c8mta93stvg8m7bh5mt">&nbsp;&nbsp;&nbsp;SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）</a>
</h3>
<h3 class="topic">
<a name="0pacpnno73ucfqjek05t2c5t8q">&nbsp;&nbsp;读写分离</a>
</h3>
<h3 class="topic">
<a name="79t44j5h2vsfmlo64f0864ancu">&nbsp;&nbsp;&nbsp;主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</a>
</h3>
<h3 class="topic">
<a name="1oa4nnm76ci60arklijhdqsu04">&nbsp;&nbsp;&nbsp;读写分离能提高性能的原因在于：</a>
</h3>
<h3 class="topic">
<a name="6big9i6jg24c34nqtuun33u18i">&nbsp;&nbsp;&nbsp;主从服务器负责各自的读和写，极大程度缓解了锁的争用；</a>
</h3>
<h3 class="topic">
<a name="5rropeekl4rh14fceerq9gpoi1">&nbsp;&nbsp;&nbsp;从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</a>
</h3>
<h3 class="topic">
<a name="74nnqoqg6seh89fgpmj676bo0o">&nbsp;&nbsp;&nbsp;增加冗余，提高可用性。</a>
</h3>
<h3 class="topic">
<a name="16oqb1vlggt5fotvd9fbembanm">&nbsp;&nbsp;&nbsp;读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</a>
</h3>
<h3 class="topic">
<a name="17h6atdjskgvm9ql8gv7de3g6h">&nbsp;&nbsp;分库</a>
</h3>
<h3 class="topic">
<a name="4b42ufb0g5u1mmim32l1nl8t8l">&nbsp;&nbsp;&nbsp; 将一堆数据放到不同的数据库中保存，上面说的都是在同一个数据库上，分库是分到不同的数据库上</a>
</h3>
<h3 class="topic">
<a name="0tl1k315fnp1qqaa4gou5osbnh">&nbsp;&nbsp;分区</a>
</h3>
<h3 class="topic">
<a name="1o0cok5ebgpi93kr5pctuoovlf">&nbsp;&nbsp;&nbsp;就是把同一个数据库里的表放到不同的服务器上，负载均衡，但是在用户上来看，只有一个服务器</a>
</h3>
<h3 class="topic">
<a name="6o395jjq0n5vgfh00ujhjkk4gl">&nbsp;NoSQL</a>
</h3>
<h3 class="topic">
<a name="0l3tvol6m0qsfvahr88sopnv2h">&nbsp;&nbsp;Redis</a>
</h3>
<h3 class="topic">
<a name="3emblk2rqiskv019nfjnhc5uqi">&nbsp;&nbsp;MongoDB</a>
</h3>
<h3 class="topic">
<a name="62srkjqbcmgco9fdvd30qvnjtk">&nbsp;&nbsp;四大分类</a>
</h3>
<h3 class="topic">
<a name="02q2uedklv15t0f2fio1cevn6c">&nbsp;&nbsp;&nbsp;KV键值对：redis</a>
</h3>
<h3 class="topic">
<a name="5oupqkj19u5j5m0052eq2l82vn">&nbsp;&nbsp;&nbsp;文档型数据库：MongoDB</a>
</h3>
<h3 class="topic">
<a name="3crti80c9q9konoj9s76tj6d7e">&nbsp;&nbsp;&nbsp;列存储数据库：HBase、分布式文件系统</a>
</h3>
<h3 class="topic">
<a name="284jmsclumrqvjvlneieo9l2mi">&nbsp;&nbsp;&nbsp;图关系数据库：社交网络Neo4J、InfoGrid</a>
</h3>
<h3 class="topic">
<a name="79i283nc9t1gsed3t57qticdn0">&nbsp;主从复制读写分离</a>
</h3>
<h3 class="topic">
<a name="3ipv7hlglcis6rdh5db3iip4t5">&nbsp;分布式与集群</a>
</h3>
<h3 class="topic">
<a name="5lha07osdeep04qeqvpifn2ln2">&nbsp;数据库信息存储方式</a>
</h3>
<h3 class="topic">
<a name="79vg7pfj52pdgj1ggqqv49td6e">&nbsp;&nbsp;商品基本信息： 稳定数据存在关系型数据库mySQL&#13;
      商品描述、详情、评价信息（多文字类）： 文档数据库MongoDB&#13;
      商品图片： 分布式的文件系统，如淘宝自己的TFS、Google的GFS、Hadoop的HDFS&#13;
      商品的关键字： 搜索引擎，如淘宝自己的ISearch&#13;
      商品的波段性的热点高频信息：  内存数据库，如Tair、Redis、Memcache&#13;
      商品的交易、价格计算、积分累计：  外部系统，支付宝</a>
</h3>
<h2 class="topic">
<a name="149gp24jgsds8h759p0ahi62qj">javaWEB</a>
</h2>
<h3 class="topic">
<a name="55gugjgn0pl24k9ahi0ts8h7s7">&nbsp;Servlet原理</a>
</h3>
<h3 class="topic">
<a name="5bf7c6ep9sa8qb5c0kbuqqiqm1">&nbsp;&nbsp;得到请求后容器检查是否实例化对应的servlet，如果没有，先装载并创建该servlet对象，调用该servlet的构造器，调用servlet实例的init方法，如果这个实例已经存在，上述过程就不要了，继续，创建一个ServletRequest对象和一个ServletResponse对象，然后调用servlet实例的service方法，并将请求和响应的对象作为参数传入，web应用程序停止时，卸载servlet，再卸载之前调用destroy方法</a>
</h3>
<h3 class="topic">
<a name="23d4hcrtd33n1tvfdjssnatkkr">&nbsp;servlet生命周期</a>
</h3>
<h3 class="topic">
<a name="2i3e6vooruidfga4e7s63ou6t6">&nbsp;&nbsp; 以下方法都是由 Serlvet 容器负责调用. </a>
</h3>
<h3 class="topic">
<a name="1gcvcmqab3pb1ob0p9p5b08ml5">&nbsp;&nbsp;1). 构造器: 只被调用一次. 只有第一次请求 Servlet 时, 创建 Servlet 的实例. 调用构造器. </a>
</h3>
<h3 class="topic">
<a name="7fg3giac8kt55pt50bnq4k2h4s">&nbsp;&nbsp;这说明 Serlvet 的单实例的!</a>
</h3>
<h3 class="topic">
<a name="7knuuai1o903c64uv77b35vdju">&nbsp;&nbsp;2). init 方法: 只被调用一次. 在创建好实例后立即被调用. 用于初始化当前 Servlet. </a>
</h3>
<h3 class="topic">
<a name="1gtglq0jbj0srro9rkc55nal1i">&nbsp;&nbsp;3). service: 被多次调用. 每次请求都会调用 service 方法. 实际用于响应请求的. </a>
</h3>
<h3 class="topic">
<a name="6520k0b1i63r9r23vk07ch6cta">&nbsp;&nbsp;4). destroy: 只被调用一次. 在当前 Servlet 所在的 WEB 应用被卸载前调用. 用于释放当前 Servlet 所占用的资源. </a>
</h3>
<h3 class="topic">
<a name="713aqfruihb5109ml1f7uhsj4h">&nbsp;jsp隐含9大对象</a>
</h3>
<h3 class="topic">
<a name="723j8q3f8cnhpo8ofmruaof1hp">&nbsp;&nbsp;①. request: HttpServletRequest 的一个对象. *</a>
</h3>
<h3 class="topic">
<a name="1a5lfu908rlctmlets61u94308">&nbsp;&nbsp;②. response: HttpServletResponse 的一个对象(在 JSP 页面中几乎不会调用 response 的任何方法.)</a>
</h3>
<h3 class="topic">
<a name="7kurni7khdqsq2haedh4psm0ep">&nbsp;&nbsp;③. pageContext: 页面的上下文, 是 PageContext 的一个对象. 可以从该对象中获取到其他 8 个隐含对象. 也可以从中获取到当前</a>
</h3>
<h3 class="topic">
<a name="7k8nmi20g0np3cot392nh1co5b">&nbsp;&nbsp;页面的其他信息. (学习自定义标签时使用它) *</a>
</h3>
<h3 class="topic">
<a name="2dr24b3r5afm0vcd21jc6o90i1">&nbsp;&nbsp;④. session: 代表浏览器和服务器的一次会话, 是 HttpSession 的一个对象. 后面详细学习. *</a>
</h3>
<h3 class="topic">
<a name="6nr0t7r5nrtvj9bldbc4l86pg5">&nbsp;&nbsp;⑤. application: 代表当前 WEB 应用. 是 ServletContext 对象. *</a>
</h3>
<h3 class="topic">
<a name="7nqrusr0ru5rspg6go82coq816">&nbsp;&nbsp;⑥. config: 当前 JSP 对应的 Servlet 的 ServletConfig 对象(几乎不使用). 若需要访问当前 JSP 配置的初始化参数, </a>
</h3>
<h3 class="topic">
<a name="2o8p2djr5tva2ocbjhg0grd8qd">&nbsp;&nbsp;需要通过映射的地址才可以.</a>
</h3>
<h3 class="topic">
<a name="3tbs7sh6g5f0ciro812grn41vv">&nbsp;&nbsp;⑦. out: JspWriter 对象. 调用 out.println() 可以直接把字符串打印到浏览器上. *</a>
</h3>
<h3 class="topic">
<a name="1rqlulrn4rhuop6p6bvhsiom66">&nbsp;&nbsp;⑧. page: 指向当前 JSP 对应的 Servlet 对象的引用, 但为 Object 类型, 只能调用 Object 类的方法(几乎不使用) </a>
</h3>
<h3 class="topic">
<a name="0ca4dj5b3hcebk90lojkne4a35">&nbsp;&nbsp;⑨. exception: 在声明了 page 指令的 isErrorPage="true" 时, 才可以使用. *</a>
</h3>
<h3 class="topic">
<a name="6qd7mbqqhbro0suonkpie6lau0">&nbsp;servlet三大组件</a>
</h3>
<h3 class="topic">
<a name="4ojgbr81q9j6s6u7jfltn6jtts">&nbsp;&nbsp;servlet</a>
</h3>
<h3 class="topic">
<a name="7faisgccb925lei32d77nj3dal">&nbsp;&nbsp;&nbsp; load-on-startup 参数:</a>
</h3>
<h3 class="topic">
<a name="11vvjqo6j3vgq6s3k278tv7ggn">&nbsp;&nbsp;&nbsp;&nbsp;配置在 servlet 节点中:</a>
</h3>
<h3 class="topic">
<a name="3e0ocbfqos2omr58jfg96g9g35">&nbsp;&nbsp;&nbsp;&nbsp;load-on-startup: 可以指定 Serlvet 被创建的时机. 若为负数, 则在第一次请求时被创建.若为 0 或正数, 则在当前 WEB 应用被&#13;
Serlvet 容器加载时创建实例, 且数组越小越早被创建. </a>
</h3>
<h3 class="topic">
<a name="6h4u0tb79dkd72io70ctno3nnj">&nbsp;&nbsp;&nbsp;ServletConfig</a>
</h3>
<h3 class="topic">
<a name="162uesls1n795et0343ji0i3hq">&nbsp;&nbsp;&nbsp;&nbsp;ServletConfig: 封装了 Serlvet 的配置信息, 并且可以获取 ServletContext 对象，调用init方法时，他就是参数</a>
</h3>
<h3 class="topic">
<a name="4vqita9up01h3m3obv2c9pi9rm">&nbsp;&nbsp;&nbsp;&nbsp;配置 Serlvet 的初始化参数</a>
</h3>
<h3 class="topic">
<a name="1655k99sn2ri36oj78k8fvt5pb">&nbsp;&nbsp;&nbsp;&nbsp;获取 Serlvet 的配置名称(了解)</a>
</h3>
<h3 class="topic">
<a name="7sj8v3pn0rf1t30ebhcvjhrmvj">&nbsp;&nbsp;&nbsp;ServletContext</a>
</h3>
<h3 class="topic">
<a name="609b4hicuj14basdccnhj45ljo">&nbsp;&nbsp;&nbsp;&nbsp;可以由  SerlvetConfig 获取:</a>
</h3>
<h3 class="topic">
<a name="794mr52gk1ldrtn77tjcquo94t">&nbsp;&nbsp;&nbsp;&nbsp;该对象代表当前 WEB 应用: 可以认为 SerlvetContext 是当前 WEB 应用的一个大管家. 可以从中获取到当前 WEB 应用的各个方面的信息.</a>
</h3>
<h3 class="topic">
<a name="0fb54ne33t41607k011jlsmmor">&nbsp;&nbsp;&nbsp;&nbsp;①. 获取当前 WEB 应用的初始化参数</a>
</h3>
<h3 class="topic">
<a name="28jrt0nt2ftsnjt0lerblnujik">&nbsp;&nbsp;&nbsp;&nbsp;②. 获取当前 WEB 应用的某一个文件在服务器上的绝对路径, 而不是实际你放的路径</a>
</h3>
<h3 class="topic">
<a name="1cq0g4ejj0cv98rklqteqdnj42">&nbsp;&nbsp;&nbsp;&nbsp;③. 获取当前 WEB 应用的名称: </a>
</h3>
<h3 class="topic">
<a name="5r8sbi6um32hjmddntis5dlm51">&nbsp;&nbsp;&nbsp;&nbsp;④. 获取当前 WEB 应用的某一个文件对应的输入流. </a>
</h3>
<h3 class="topic">
<a name="3umj03idctqq87020aj5rfs348">&nbsp;&nbsp;&nbsp;&nbsp;⑤. 和 attribute 相关的几个方法: 	</a>
</h3>
<h3 class="topic">
<a name="4nble316ibfnoil20amb9h0nhm">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pageContext, request, session, application 对象都有这些方法!&#13;
这四个对象也称之为域对象. </a>
</h3>
<h3 class="topic">
<a name="1bf8somqitphaorsin29njrdqj">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pageContext: 属性的作用范围仅限于当前 JSP 页面</a>
</h3>
<h3 class="topic">
<a name="353kio5dnthelghoflio9puron">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request:  属性的作用范围仅限于同一个请求. </a>
</h3>
<h3 class="topic">
<a name="32efgfshbjbc1fi6se2n797phl">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session: 属性的作用范围限于一次会话: 浏览器打开直到关闭称之为一次会话(在此期间会话不失效)</a>
</h3>
<h3 class="topic">
<a name="23s59rglagb312rp7i0p102cqr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;application: 属性的作用范围限于当前 WEB 应用. 是范围最大的属性作用范围, 只要在一处设置属性, 在其他各处的 JSP 或 Servlet 中</a>
</h3>
<h3 class="topic">
<a name="0edd6inbdct955t9dhgbgetaou">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;都可以获取到. </a>
</h3>
<h3 class="topic">
<a name="6o7ku49q9v0amm173ftcb7bfm5">&nbsp;&nbsp;&nbsp;ServletRequest</a>
</h3>
<h3 class="topic">
<a name="6ndm44ei3fkjc4vh6gnniqepp9">&nbsp;&nbsp;&nbsp;&nbsp;可以获得SevletContext</a>
</h3>
<h3 class="topic">
<a name="0br84ppll2miiqcdmfnopedu8d">&nbsp;&nbsp;&nbsp;&nbsp;获取RequestDispacher完成转发</a>
</h3>
<h3 class="topic">
<a name="5to8gqnb4idbe349bd7881pkv4">&nbsp;&nbsp;&nbsp;ServletResponse</a>
</h3>
<h3 class="topic">
<a name="5jdqt02p1q5hb2qvn6694s4n01">&nbsp;&nbsp;&nbsp;&nbsp;请求的重定向：sendRedirect</a>
</h3>
<h3 class="topic">
<a name="4g2dck6mrqfj2a2vt1avi3kfdp">&nbsp;&nbsp;filter</a>
</h3>
<h3 class="topic">
<a name="3d9nferfe70spvkcqbh0u1u0go">&nbsp;&nbsp;&nbsp;1. Filter:&#13;
&#13;
1). Filter 是什么 ?&#13;
&#13;
①. JavaWEB 的一个重要组件, 可以对发送到 Servlet 的请求进行拦截, 并对响应也进行拦截. &#13;
②. Filter 是实现了 Filter 接口的 Java 类.&#13;
③. Filter 需要在 web.xml 文件中进行配置和映射. &#13;
&#13;
2). 如何创建一个 Filter, 并把他跑起来&#13;
&#13;
①. 创建一个 Filter 类: 实现 Filter 接口: public class HelloFilter implements Filter&#13;
②. 在 web.xml 文件中配置并映射该 Filter. 其中 url-pattern 指定该 Filter 可以拦截哪些资源, 即可以通过哪些 url 访问到该 Filter&#13;
&#13;
&lt;!-- 注册 Filter --&gt;&#13;
&lt;filter&gt;&#13;
	&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;&#13;
	&lt;filter-class&gt;com.atguigu.javaweb.HelloFilter&lt;/filter-class&gt;&#13;
&lt;/filter&gt;&#13;
&#13;
&lt;!-- 映射 Filter --&gt;&#13;
&lt;filter-mapping&gt;&#13;
	&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;&#13;
	&lt;url-pattern&gt;/test.jsp&lt;/url-pattern&gt;&#13;
&lt;/filter-mapping&gt;&#13;
&#13;
3). Filter 相关的 API:&#13;
&#13;
①. Filter 接口:&#13;
&#13;
	&gt; public void init(FilterConfig filterConfig): 类似于 Servlet 的 init 方法. 在创建 Filter 对象(Filter 对象在 Servlet 容器加载当前 WEB 应用时即被创建)后, &#13;
	立即被调用, 且只被调用一次. 该方法用于对当前的 Filter 进行初始化操作. Filter 实例是单例的. &#13;
	&#13;
		*  FilterConfig 类似于 ServletConfig&#13;
		&#13;
		* 可以在 web.xml 文件中配置当前 Filter 的初始化参数. 配置方式也和 Servlet 类似。&#13;
		&#13;
		&lt;filter&gt;&#13;
			&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;&#13;
			&lt;filter-class&gt;com.atguigu.javaweb.HelloFilter&lt;/filter-class&gt;&#13;
			&lt;init-param&gt;&#13;
				&lt;param-name&gt;name&lt;/param-name&gt;&#13;
				&lt;param-value&gt;root&lt;/param-value&gt;&#13;
			&lt;/init-param&gt;&#13;
		&lt;/filter&gt;&#13;
&#13;
	&gt; public void doFilter(ServletRequest request, ServletResponse response,&#13;
			FilterChain chain): 真正 Filter 的逻辑代码需要编写在该方法中. 每次拦截都会调用该方法. &#13;
			&#13;
		* FilterChain: Filter 链. 多个 Filter 可以构成一个 Filter 链. 	&#13;
		&#13;
			- doFilter(ServletRequest request, ServletResponse response): 把请求传给 Filter 链的下一个 Filter,&#13;
			若当前 Filter 是 Filter 链的最后一个 Filter, 将把请求给到目标 Serlvet(或 JSP)	&#13;
			&#13;
			- 多个 Filter 拦截的顺序和 &lt;filter-mapping&gt; 配置的顺序有关, 靠前的先被调用. &#13;
			&#13;
	&gt; public void destroy(): 释放当前 Filter 所占用的资源的方法. 在 Filter 被销毁之前被调用, 且只被调用一次. &#13;
	&#13;
4). &lt;dispatcher&gt; 元素: 指定过滤器所拦截的资源被 Servlet 容器调用的方式，&#13;
可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST. &#13;
可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截&#13;
&#13;
①. REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。&#13;
&#13;
通过 GET 或 POST 请求直接访问。 &#13;
&#13;
②. FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。&#13;
&#13;
或 &lt;jsp:forward page="/..." /&gt; 或 通过 page 指令的 errorPage 转发页面. &lt;%@ page errorPage="test.jsp" %&gt;&#13;
&#13;
②. INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。&#13;
&#13;
或 &lt;jsp:include file="/..." /&gt;&#13;
&#13;
④. ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。&#13;
&#13;
在 web.xml 文件中通过 error-page 节点进行声明:&#13;
&#13;
&lt;error-page&gt;&#13;
	&lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt;&#13;
	&lt;location&gt;/test.jsp&lt;/location&gt;&#13;
&lt;/error-page&gt;&#13;
&#13;
&lt;filter-mapping&gt;&#13;
	&lt;filter-name&gt;secondFilter&lt;/filter-name&gt;&#13;
	&lt;url-pattern&gt;/test.jsp&lt;/url-pattern&gt;&#13;
	&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&#13;
	&lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&#13;
	&lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;&#13;
	&lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;&#13;
&lt;/filter-mapping&gt;&#13;
	&#13;
&#13;
	</a>
</h3>
<h3 class="topic">
<a name="0fnn93pg4tb88sua9q61u81uja">&nbsp;&nbsp;listener</a>
</h3>
<h3 class="topic">
<a name="3862aajtg3toguipt1di08rr6e">&nbsp;&nbsp;&nbsp;专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象</a>
</h3>
<h3 class="topic">
<a name="0i3kjh1nsck6kkd3gs92pdbc05">&nbsp;&nbsp;&nbsp;监听ServletContext\HttpSession\ServletRequest等</a>
</h3>
<h3 class="topic">
<a name="6hkh9qd80cttfegi08gejfaco8">&nbsp;转发与重定向</a>
</h3>
<h3 class="topic">
<a name="6m2cikdsrcaa7vpj5vdpagu94d">&nbsp;&nbsp;本质区别: 请求的转发只发出了一次请求, 而重定向则发出了两次请求. </a>
</h3>
<h3 class="topic">
<a name="0qji210ehbu4rj1ianqd1urjvq">&nbsp;&nbsp;①. 请求的转发: 地址栏是初次发出请求的地址.&#13;
       请求的重定向: 地址栏不再是初次发出的请求地址. 地址栏为最后响应的那个地址 &#13;
       &#13;
②. 请求转发: 在最终的 Servlet 中, request 对象和中转的那个 request 是同一个对象. &#13;
       请求的重定向: 在最终的 Servlet 中, request 对象和中转的那个 request 不是同一个对象.       &#13;
   &#13;
③. 请求的转发: 只能转发给当前 WEB 应用的的资源&#13;
       请求的重定向: 可以重定向到任何资源. &#13;
       &#13;
④. 请求的转发: / 代表的是当前 WEB 应用的根目录&#13;
       请求的重定向: / 代表的是当前 WEB 站点的根目录. </a>
</h3>
<h3 class="topic">
<a name="39e3ilhi8b4ipoo7mbhibtcken">&nbsp;get与Post</a>
</h3>
<h3 class="topic">
<a name="7m03em2rhkjnf5p7ioup9o7tpe">&nbsp;&nbsp;1). 使用GET方式传递参数:&#13;
&#13;
①. 在浏览器地址栏中输入某个URL地址或单击网页上的一个超链接时，浏览器发出的HTTP请求消息的请求方式为GET。 &#13;
②. 如果网页中的&lt;form&gt;表单元素的 method 属性被设置为了&ldquo;GET&rdquo;，浏览器提交这个FORM表单时生成的HTTP请求消息的请求方式也为GET。 &#13;
③. 使用GET请求方式给WEB服务器传递参数的格式：  &#13;
&#13;
http://www.atguigu.com/counter.jsp?name=lc&amp;password=123&#13;
&#13;
④. 使用GET方式传送的数据量一般限制在 1KB 以下。 &#13;
&#13;
2). 使用 POST 方式传递参数:&#13;
&#13;
①. POST 请求方式主要用于向 WEB 服务器端程序提交 FORM 表单中的数据: form 表单的 method 置为 POST&#13;
②. POST 方式将各个表单字段元素及其数据作为 HTTP 消息的实体内容发送给 WEB 服务器，传送的数据量要比使用GET方式传送的数据量大得多。  &#13;
&#13;
POST /counter.jsp HTTP/1.1&#13;
referer: http://localhost:8080/Register.html&#13;
content-type: application/x-www-form-urlencoded&#13;
host: localhost:8080&#13;
content-length: 43&#13;
&#13;
name=zhangsan&amp;password=123              --请求体中传递参数. &#13;
</a>
</h3>
<h3 class="topic">
<a name="51blmsj2h9njbq4q4rurkao4qh">&nbsp;Session和Cookie</a>
</h3>
<h3 class="topic">
<a name="3b8a129nsku451qt7o3sqau5dp">&nbsp;&nbsp;Session</a>
</h3>
<h3 class="topic">
<a name="2gd8afv5ahkqjmgrupij5qc02t">&nbsp;&nbsp;&nbsp;page 指定的 session 属性: &#13;
&#13;
1). 默认情况下, 第一次访问一个 WEB 应用的一个 JSP 页面时, 该页面都必须有一个和这个请求相关联的 Session 对象. &#13;
因为 page 指定的 session 属性默认为 true&#13;
&#13;
2). 若把 session 属性改为 false, JSP 页面不会要求一定有一个 Session 对象和当前的 JSP 页面相关联&#13;
所以若第一次访问当前 WEB 应用的 JSP 页面时, 就不会创建一个 Session 对象. &#13;
&#13;
3). 创建一个 Session 对象: 若 page 指定的 session 设置为 false 或 在 Servlet 中可以通过以下 API 获取 Session 对象. &#13;
&#13;
request.getSession(flag): 若 flag 为 true, 则一定会返回一个 HttpSession 对象, 如果已经有和当前 JSP 页面关联的 HttpSession&#13;
对象, 直接返回; 如果没有, 则创建一个新的返回. flag 为 false: 若有关联的, 则返回; 若没有, 则返回 null&#13;
&#13;
request.getSession(): 相当于 request.getSession(true);&#13;
&#13;
4). Session 对象的销毁: &#13;
&#13;
①. 直接调用 HttpSession 的 invalidate()&#13;
②. HttpSession 超过过期时间. &#13;
&#13;
	&gt; 返回最大时效: getMaxInactiveInterval() 单位是秒&#13;
	&gt; 设置最大时效: setMaxInactiveInterval(int interval)&#13;
	&gt; 可以在 web.xml 文件中配置 Session 的最大时效, 单位是分钟. &#13;
	&#13;
	&lt;session-config&gt;&#13;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;&#13;
    &lt;/session-config&gt;&#13;
&#13;
③. 卸载当前 WEB 应用. &#13;
注意: 关闭浏览器不会销毁 Session!&#13;
&#13;
</a>
</h3>
<h3 class="topic">
<a name="11lc8prkpg9dbqjdo89psq3f8s">&nbsp;&nbsp;Cookie</a>
</h3>
<h3 class="topic">
<a name="0o30tr0cgdjbj33fck38bbqqvv">&nbsp;&nbsp;&nbsp;客户端第一次访问服务器时，服务器创建cookie，存放特定的数据，并放到response中，返回给客户端，然后客户端再此发起请求时，经这个cookie带入request中</a>
</h3>
<h2 class="topic">
<a name="363523n32o5ftgn406pqh128e1">计算机网络</a>
</h2>
<h3 class="topic">
<a name="1a333stpkvfvokjp3bpqvq2g91">&nbsp;HTTP与Web</a>
</h3>
<h3 class="topic">
<a name="2u3nnmftl33vn8jrqinu93q4ta">&nbsp;TCP与UDP</a>
</h3>
<h2 class="topic">
<a name="7t30h9qbbv0ma8nfl4j6s3dp69">数据结构与算法</a>
</h2>
<h3 class="topic">
<a name="6ub2a555k6l9597f2a4uncupn9">&nbsp;栈</a>
</h3>
<h3 class="topic">
<a name="2mcratul5vcitdnmbbjsvq1l09">&nbsp;队列</a>
</h3>
<h3 class="topic">
<a name="5fjiddr1f67516vppr4mejf8c8">&nbsp;堆</a>
</h3>
<h3 class="topic">
<a name="3cetgfovm8cllau62qiqiivvg6">&nbsp;树</a>
</h3>
<h3 class="topic">
<a name="3r8on781di7rer647r08l3qu7n">&nbsp;图</a>
</h3>
<h3 class="topic">
<a name="6ubr5o88runrb90f90sni26e7n">&nbsp;排序</a>
</h3>
<h3 class="topic">
<a name="4d6624sf9d5patm8ujk6jnbihf">&nbsp;查找</a>
</h3>
<h3 class="topic">
<a name="4qdjnkapap1d2mmnmbenbp0hvu">&nbsp;回溯</a>
</h3>
<h3 class="topic">
<a name="4mha0njr8rs2dm2lger0d94m4c">&nbsp;分治法</a>
</h3>
<h3 class="topic">
<a name="1jeivh6f9o7e06pts3p182qb86">&nbsp;动态规划</a>
</h3>
<h2 class="topic">
<a name="46ap7lnb53dtmb38ggrmsi1mi6">计算机操作系统</a>
</h2>
<h3 class="topic">
<a name="1pjg5uth6nsgv2d7u7b7h71fvv">&nbsp;进程管理</a>
</h3>
<h3 class="topic">
<a name="0rn3c3p1qlft88nlrdiq131lmd">&nbsp;线程</a>
</h3>
<h3 class="topic">
<a name="3fp8is0uqpl961u31u0ef1mcf4">&nbsp;同步</a>
</h3>
<h3 class="topic">
<a name="5iu00rfpqhf64csohc70b8o45v">&nbsp;&nbsp;信号量机制</a>
</h3>
<h3 class="topic">
<a name="73iohpc5vu6327km76t8almlbv">&nbsp;&nbsp;同步代码块</a>
</h3>
<h3 class="topic">
<a name="44soglvurpf3k1n0f0mikdj246">&nbsp;&nbsp;管程</a>
</h3>
<h3 class="topic">
<a name="28qkj5ipvontpck9snbhhb32uu">&nbsp;进程通信</a>
</h3>
<h3 class="topic">
<a name="05gp9urr68n5jg8f2g09nuuoe4">&nbsp;死锁</a>
</h3>
<h3 class="topic">
<a name="3amqn068d27trvucn3f0k14bbu">&nbsp;&nbsp;死锁形成的原因和必要条件</a>
</h3>
<h3 class="topic">
<a name="10l31c8tfc1oh5hfief0vinat1">&nbsp;&nbsp;&nbsp;互斥</a>
</h3>
<h3 class="topic">
<a name="3asp1v39btb8ofqoo7e4t031a4">&nbsp;&nbsp;&nbsp;占有和等待</a>
</h3>
<h3 class="topic">
<a name="5fu9o47d1r71enl7so0dhluum8">&nbsp;&nbsp;&nbsp;不可抢占</a>
</h3>
<h3 class="topic">
<a name="0duqv8qeujd4ivm1d9sp6pha56">&nbsp;&nbsp;&nbsp;环路等待</a>
</h3>
<h3 class="topic">
<a name="4q6al1bh4rkgsf3uknqducga7o">&nbsp;&nbsp;解决死锁的方法</a>
</h3>
<h3 class="topic">
<a name="7gd57dn9bfdcq4gasusbgis5rr">&nbsp;&nbsp;&nbsp;死锁预防</a>
</h3>
<h3 class="topic">
<a name="42qkt1bifk0donq8b2dgkb9e4b">&nbsp;&nbsp;&nbsp;&nbsp;破坏必要条件</a>
</h3>
<h3 class="topic">
<a name="5q4qg7k12fs9ag42vi2l7c0m6s">&nbsp;&nbsp;&nbsp;死锁避免</a>
</h3>
<h3 class="topic">
<a name="7qhl2hgai4f2gjof4orm8prp7u">&nbsp;&nbsp;&nbsp;&nbsp;银行家算法</a>
</h3>
<h3 class="topic">
<a name="5070ta889v81tiogkvsguhjv05">&nbsp;&nbsp;&nbsp;死锁检测与解除</a>
</h3>
<h3 class="topic">
<a name="4t0da0so5u31s8m500pupg798u">&nbsp;&nbsp;&nbsp;&nbsp;抢占</a>
</h3>
<h3 class="topic">
<a name="6j28keq13earvjo1qqssk1u6kp">&nbsp;&nbsp;&nbsp;&nbsp;终止</a>
</h3>
<h3 class="topic">
<a name="6ijr54jlanf69ern2o8p4uln7h">&nbsp;&nbsp;&nbsp;鸵鸟政策</a>
</h3>
<h2 class="topic">
<a name="212emul3b795tpdn70ta229lbd">Spring整合</a>
</h2>
<h3 class="topic">
<a name="3mog1u7c379uhvfb6icrc4q7l8">&nbsp;日志</a>
</h3>
<h3 class="topic">
<a name="4di7hto4vho8rnstkfcba6bl6f">&nbsp;&nbsp;slf4j</a>
</h3>
<h3 class="topic">
<a name="5ohuohen1ce44t5vfls26er97e">&nbsp;数据访问</a>
</h3>
<h3 class="topic">
<a name="594nkqqpog2uitmu9d4sanmvlu">&nbsp;&nbsp;JDBC</a>
</h3>
<h3 class="topic">
<a name="7ohhhv19uqona0prcimbau5nf4">&nbsp;&nbsp;Druid</a>
</h3>
<h3 class="topic">
<a name="0emf6tlmova4sdfeqjb26r3m05">&nbsp;&nbsp;mybatis（plus）</a>
</h3>
<h3 class="topic">
<a name="71fmteonkhesosmmjpa0obo4hv">&nbsp;&nbsp;spring data JPA</a>
</h3>
<h3 class="topic">
<a name="7pt9o5rnjmannr4e9u8v6rpal5">&nbsp;缓存</a>
</h3>
<h3 class="topic">
<a name="5ft7gtltbp134so7rqq5ee0t32">&nbsp;&nbsp;Redis</a>
</h3>
<h3 class="topic">
<a name="23ku8qfcu3001amrbvec0o2mcg">&nbsp;&nbsp;&nbsp;RedisConfig</a>
</h3>
<h3 class="topic">
<a name="7u2pepjqenq0unitbbcu8q0pr5">&nbsp;&nbsp;&nbsp;&nbsp;RedisTemplate</a>
</h3>
<h3 class="topic">
<a name="11f2q82qtem0r2ap1k9qnlklt5">&nbsp;&nbsp;&nbsp;&nbsp;RedisCacheManager</a>
</h3>
<h3 class="topic">
<a name="11p92a60dki76mcshosuttmibe">&nbsp;&nbsp;Cache</a>
</h3>
<h3 class="topic">
<a name="1sodfsb46e61animfehutjcoic">&nbsp;&nbsp;&nbsp;缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等</a>
</h3>
<h3 class="topic">
<a name="7nmpgh069ke65iqcckuhh99an6">&nbsp;&nbsp;CacheManager</a>
</h3>
<h3 class="topic">
<a name="314gq60f2rmnmcsrgu3ug2rkg8">&nbsp;&nbsp;&nbsp;缓存管理器，管理各种缓存（Cache）组件</a>
</h3>
<h3 class="topic">
<a name="50ost0k4dtg0odla4b2se03nod">&nbsp;&nbsp;@Cacheable</a>
</h3>
<h3 class="topic">
<a name="7aeq87hajolrltg1i9thng437q">&nbsp;&nbsp;&nbsp;主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</a>
</h3>
<h3 class="topic">
<a name="2ckg6vv0dirmngaq1tp521i49j">&nbsp;&nbsp;@CacheEvict</a>
</h3>
<h3 class="topic">
<a name="3rg3kc9elh60cn12jt8gcfe3br">&nbsp;&nbsp;&nbsp;清空缓存</a>
</h3>
<h3 class="topic">
<a name="7ckable19ih3qoc60d2cvi8ld2">&nbsp;&nbsp;@CachePut</a>
</h3>
<h3 class="topic">
<a name="0nckfkjm206svfthtdqd8482qo">&nbsp;&nbsp;&nbsp;保证方法被调用，又希望结果被缓存。</a>
</h3>
<h3 class="topic">
<a name="5gev5nev7qsos7d37geip0o90f">&nbsp;&nbsp;@EnableCaching</a>
</h3>
<h3 class="topic">
<a name="7t9aenhcelcip2nujf1k5bkuj2">&nbsp;&nbsp;&nbsp;开启基于注解的缓存,用于Config文件</a>
</h3>
<h3 class="topic">
<a name="0a8niqm09smaq2ujiate1r1ihf">&nbsp;&nbsp;keyGenerator</a>
</h3>
<h3 class="topic">
<a name="5gdaa2ccr5pdqu2lvidduguaui">&nbsp;&nbsp;&nbsp;缓存数据时key生成策略</a>
</h3>
<h3 class="topic">
<a name="5alehc5sr769nkgc48c3aj0jaj">&nbsp;&nbsp;serialize</a>
</h3>
<h3 class="topic">
<a name="7f3ql532fp8u64j97ii8ej62qk">&nbsp;&nbsp;&nbsp;缓存数据时value序列化策略</a>
</h3>
<h3 class="topic">
<a name="42ieablsk6ucfj1kc76na1e64r">&nbsp;&nbsp;spEL表达式：</a>
</h3>
<h3 class="topic">
<a name="26motmuf28d4dkg1rt3799fgn7">&nbsp;&nbsp;&nbsp;https://www.jianshu.com/p/b8fd074e2802</a>
</h3>
<h3 class="topic">
<a name="08isn9n6chpeu1pou8ip6qvaqm">&nbsp;&nbsp;缓存原理</a>
</h3>
<h3 class="topic">
<a name="6eegdtaoc1p3lol8ikf2mta02a">&nbsp;消息</a>
</h3>
<h3 class="topic">
<a name="0ufu4u08r3m99ss7hf4r5hnp5g">&nbsp;&nbsp;RabbitMQ</a>
</h3>
<h3 class="topic">
<a name="4g1k65r4andasecptco9tilkr9">&nbsp;&nbsp;&nbsp;EnableRabbit</a>
</h3>
<h3 class="topic">
<a name="4v2544ta3npa3jfhec69k5nhq3">&nbsp;&nbsp;&nbsp;RabbitListener</a>
</h3>
<h3 class="topic">
<a name="2m9eg4v2bb9gtp65el6fs37a8a">&nbsp;&nbsp;&nbsp;RabbitAutoConfig</a>
</h3>
<h3 class="topic">
<a name="090vhr1pvndv6h2m1imlr6qs51">&nbsp;&nbsp;&nbsp;RabbitTamplate</a>
</h3>
<h3 class="topic">
<a name="4m14qc1ra6dv0712s6t6vood86">&nbsp;&nbsp;&nbsp;AmqpAdmin</a>
</h3>
<h3 class="topic">
<a name="0972h8hi13cpgfktsg0k9hdg9o">&nbsp;全文检索</a>
</h3>
<h3 class="topic">
<a name="54gttvbehrgq4u13m4dk7ie3h6">&nbsp;&nbsp;Elasticsearch</a>
</h3>
<h3 class="topic">
<a name="570nad9fnh017d1fakbbp3qhhc">&nbsp;任务</a>
</h3>
<h3 class="topic">
<a name="19kg99rdejdkn6puusp1v8em5h">&nbsp;&nbsp;异步任务</a>
</h3>
<h3 class="topic">
<a name="3oldsijtfglhk2sfuus2u0nr0v">&nbsp;&nbsp;&nbsp;@Async</a>
</h3>
<h3 class="topic">
<a name="16a27ti6lakj49cssdoof56oc2">&nbsp;&nbsp;&nbsp;@EnableAsync</a>
</h3>
<h3 class="topic">
<a name="79l4ah6he1dk7brhevfdl4omhn">&nbsp;&nbsp;定时任务</a>
</h3>
<h3 class="topic">
<a name="5tdset02tlo0evrtdba151nhd7">&nbsp;&nbsp;&nbsp;@EnableScheduling</a>
</h3>
<h3 class="topic">
<a name="6s2qr1s8hfies4ffa4om86h8jk">&nbsp;&nbsp;&nbsp;@Scheduled</a>
</h3>
<h3 class="topic">
<a name="4vt5st0a83f3es1enfuqaum5s9">&nbsp;&nbsp;邮件任务</a>
</h3>
<h3 class="topic">
<a name="7c10ank2l62glt0pl5k2u3pivo">&nbsp;安全与权限</a>
</h3>
<h3 class="topic">
<a name="6v8jg6kgnk2kogtgcen3hv1eul">&nbsp;&nbsp;shiro</a>
</h3>
<h3 class="topic">
<a name="6cv6s0k9rfkcarhpstnscm5bbc">&nbsp;分布式与微服务</a>
</h3>
<h3 class="topic">
<a name="63mk1g0pj4gn7ijotvrh8nbvkv">&nbsp;&nbsp;springCloud</a>
</h3>
<h3 class="topic">
<a name="6a5ibegsva9m6gaem9jsip262d">&nbsp;&nbsp;Dubbo</a>
</h3>
<h3 class="topic">
<a name="1j140fee24jpmc7l719k9bcj3i">&nbsp;Netty</a>
</h3>
<h3 class="topic">
<a name="7st1pat9u323askuublljjqg67">&nbsp;REST</a>
</h3>
<h3 class="topic">
<a name="56nuc7vjfj2ckfv15s2rrh9bmg">&nbsp;部署</a>
</h3>
<h2 class="topic">
<a name="2glrdvcbukkovdgcjt9u7lgv7c">Docker</a>
</h2>
<h2 class="topic">
<a name="2ifrk9pvcsomfgnodj5hvs4poj">系统设计</a>
</h2>
<h3 class="topic">
<a name="7lnfjbtiu2dothdabh22r37e9o">&nbsp;分布式</a>
</h3>
<h3 class="topic">
<a name="69hlsgkvkf7erfhl57l3bh4ksd">&nbsp;微服务</a>
</h3>
<h2 class="topic">
<a name="3lpdbp86kd87c2m67ss4bnesge">spring原理</a>
</h2>
<h3 class="topic">
<a name="64ht1biu2gtrkh83iqo6jkbh1l">&nbsp;Bean</a>
</h3>
<h3 class="topic">
<a name="55ddpaodiq3l95mebo10pffb41">&nbsp;&nbsp;Bean的概念</a>
</h3>
<h3 class="topic">
<a name="4doq7pp7tc7so43m3ktamp7esk">&nbsp;&nbsp;Bean之间的关系</a>
</h3>
<h3 class="topic">
<a name="4u5trb1esmqf887linbkbb2o9e">&nbsp;&nbsp;&nbsp;继承</a>
</h3>
<h3 class="topic">
<a name="5cl3juo7dkjasfimn0qin8a5b7">&nbsp;&nbsp;&nbsp;依赖</a>
</h3>
<h3 class="topic">
<a name="35km6tjrr0k72vda8fpqbru6kt">&nbsp;&nbsp;Bean的作用域</a>
</h3>
<h3 class="topic">
<a name="327sg2146a6nh49darc7u160mh">&nbsp;&nbsp;&nbsp;singleton</a>
</h3>
<h3 class="topic">
<a name="6qan3khnu3bhgrp7khdopeual5">&nbsp;&nbsp;&nbsp;prototype</a>
</h3>
<h3 class="topic">
<a name="2i64u7dqq2a2b164fs90c5bunf">&nbsp;&nbsp;&nbsp;仅用于Web环境下的四个</a>
</h3>
<h3 class="topic">
<a name="1aci6kjfcv5eviii30hdq4op9r">&nbsp;&nbsp;&nbsp;&nbsp;request</a>
</h3>
<h3 class="topic">
<a name="5l9o93hbb5kqck3s4571p03hv7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将单个bean定义范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。仅在具有Web感知功能的Spring环境中有效ApplicationContext</a>
</h3>
<h3 class="topic">
<a name="3mnfr4dpulff0ohf8jk2dipe76">&nbsp;&nbsp;&nbsp;&nbsp;session</a>
</h3>
<h3 class="topic">
<a name="1pteutf94erc7rbkdo8orisv49">&nbsp;&nbsp;&nbsp;&nbsp;application</a>
</h3>
<h3 class="topic">
<a name="6i96oh4f998d5sidgcjt5c87lj">&nbsp;&nbsp;&nbsp;&nbsp;websocket</a>
</h3>
<h3 class="topic">
<a name="11rp2r242qtbhtsvigtr2244ai">&nbsp;&nbsp;Bean的配置</a>
</h3>
<h3 class="topic">
<a name="62pn75h2afv0mm88qe2sjut33j">&nbsp;&nbsp;&nbsp;基于XML</a>
</h3>
<h3 class="topic">
<a name="0l7souv08h1s88ncin8q2qk9ul">&nbsp;&nbsp;&nbsp;基于注解</a>
</h3>
<h3 class="topic">
<a name="1m3t3c994fb2ltdsdd6qjqld5r">&nbsp;&nbsp;&nbsp;配置方式</a>
</h3>
<h3 class="topic">
<a name="223op039ltetiaikbj058rr1ig">&nbsp;&nbsp;&nbsp;&nbsp;反射</a>
</h3>
<h3 class="topic">
<a name="5gksotkjr9fqm730etko0s3o64">&nbsp;&nbsp;&nbsp;&nbsp;工厂方法</a>
</h3>
<h3 class="topic">
<a name="5gvq8uu3e00m4ioqkov89h6kgv">&nbsp;&nbsp;&nbsp;&nbsp;FactoryBean</a>
</h3>
<h3 class="topic">
<a name="1609snrhinnttb45n2dva3nqkl">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现FactoryBean&lt;T&gt;接口</a>
</h3>
<h3 class="topic">
<a name="6ech8eek1ellq6ipous1rfh0kg">&nbsp;&nbsp;Bean的生命周期</a>
</h3>
<h3 class="topic">
<a name="2up0e691sltts13v39btn8rhcu">&nbsp;&nbsp;&nbsp;通过构造器或者工厂方法创建Bean实例</a>
</h3>
<h3 class="topic">
<a name="43vnr4g5rn09eftu0hongetjq2">&nbsp;&nbsp;&nbsp;为Bean的属性设置值和对其他Bean的引用</a>
</h3>
<h3 class="topic">
<a name="495nj89i0udu6iqnnqkda2q000">&nbsp;&nbsp;&nbsp;Bean初始化</a>
</h3>
<h3 class="topic">
<a name="1o4hjdfhci3stvc5tjcm00v7g3">&nbsp;&nbsp;&nbsp;使用</a>
</h3>
<h3 class="topic">
<a name="5hqhsndofsq2ivr7bseb6nihtm">&nbsp;&nbsp;&nbsp;容器关闭时销毁</a>
</h3>
<h3 class="topic">
<a name="2jamg4cu0m9765q7himu8kkva6">&nbsp;IoC与DI</a>
</h3>
<h3 class="topic">
<a name="6d3norcoojs3v5cvo6j2b2ufgm">&nbsp;&nbsp;IoC就是容器自动给我们我们需要的对象，传统方式时我们主动去获得对象</a>
</h3>
<h3 class="topic">
<a name="6raktvqk4chpmt2mn64d09m5at">&nbsp;&nbsp;DI依赖注入是实现IoC的一种手段</a>
</h3>
<h3 class="topic">
<a name="63tudtcr7cbipaih8lsgtjm4rp">&nbsp;AOP原理</a>
</h3>
<h3 class="topic">
<a name="6h97k6bomr0gvkg3knqmvj103b">&nbsp;&nbsp;AOP术语</a>
</h3>
<h3 class="topic">
<a name="6gc5dhm3vl2m9shl2mtmt3gfk1">&nbsp;&nbsp;AOP原理解析</a>
</h3>
<h3 class="topic">
<a name="4nfitb0a7vjhcp71m7loq01ndp">&nbsp;&nbsp;&nbsp;说起AOP就不得不说下OOP了，OOP中引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。但是，如果我们需要为部分对象引入公共部分的时候，OOP就会引入大量重复的代码。例如：日志功能。&#13;
　　AOP技术利用一种称为&ldquo;横切&rdquo;的技术，解剖封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，这样就能减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。</a>
</h3>
<h3 class="topic">
<a name="06osus05q20a2gdi43u8s7vej6">&nbsp;&nbsp;AOP应用场景</a>
</h3>
<h3 class="topic">
<a name="7i0n6ugesc5s55lul6ahabe437">&nbsp;&nbsp;&nbsp;事务管理</a>
</h3>
<h3 class="topic">
<a name="0k8tt32oc8ub92e6qtt6e69ech">&nbsp;&nbsp;&nbsp;&nbsp;这个从数据库的JDBC操作try,catch,finally即可理解</a>
</h3>
<h3 class="topic">
<a name="6ok51d9auc8jnuusstdd95es4r">&nbsp;&nbsp;&nbsp;自定义切面实现OOP</a>
</h3>
<h3 class="topic">
<a name="792btetjtprfio5lsqu8bdht47">&nbsp;&nbsp;AOP注解</a>
</h3>
<h3 class="topic">
<a name="5109rflp2l5mjmk3pbjjdfevcp">&nbsp;&nbsp;&nbsp;@Aspect</a>
</h3>
<h3 class="topic">
<a name="6j4i6l4u44laugk2qei8b9sh1b">&nbsp;&nbsp;&nbsp;&nbsp;把一个类声明为一个切面</a>
</h3>
<h3 class="topic">
<a name="3gd9989iqis2btehhj3odv9f74">&nbsp;&nbsp;&nbsp;@Before</a>
</h3>
<h3 class="topic">
<a name="4d8pn3alr1o9uer74b5olq6v51">&nbsp;&nbsp;&nbsp;&nbsp;前置通知，在方法执行前执行</a>
</h3>
<h3 class="topic">
<a name="4sf3jia7av77q5tcpipraet1h0">&nbsp;&nbsp;&nbsp;@After</a>
</h3>
<h3 class="topic">
<a name="646l6cu5act2cke0tt89qusb5v">&nbsp;&nbsp;&nbsp;&nbsp;后置通知，在方法执行后执行</a>
</h3>
<h3 class="topic">
<a name="35bsto90lgb8rr9sg71fnf5ir9">&nbsp;&nbsp;&nbsp;@AfterRunning</a>
</h3>
<h3 class="topic">
<a name="7fpfhsprni9i06tfldqo8tvam2">&nbsp;&nbsp;&nbsp;&nbsp;返回通知，在方法返回结果之后执行</a>
</h3>
<h3 class="topic">
<a name="39e8fm2gqv85eri048nbr4n5d1">&nbsp;&nbsp;&nbsp;@AfterThrowing</a>
</h3>
<h3 class="topic">
<a name="108s6pbf6c87t0ct39n43k2965">&nbsp;&nbsp;&nbsp;&nbsp;异常通知，在方法抛出异常之后执行</a>
</h3>
<h3 class="topic">
<a name="7sm151pkk30qkguafa04lj50bq">&nbsp;&nbsp;&nbsp;&nbsp;可以传一个Exception类型参数，用于特定的异常通知</a>
</h3>
<h3 class="topic">
<a name="296orha7370j9rg2c0p882apec">&nbsp;&nbsp;&nbsp;@Around</a>
</h3>
<h3 class="topic">
<a name="2tg9oqbd32edq3bi857lue6k58">&nbsp;&nbsp;&nbsp;&nbsp;环绕通知，围绕着方法执行</a>
</h3>
<h3 class="topic">
<a name="3kemu0tk7nimqn2hffaekg0l8m">&nbsp;&nbsp;&nbsp;&nbsp;上述通知均可在这里实现</a>
</h3>
<h3 class="topic">
<a name="5ro589io9anvi2j2kcqqd3gvpu">&nbsp;&nbsp;&nbsp;&nbsp;需要携带ProceedingJoinPoint类型的参数</a>
</h3>
<h3 class="topic">
<a name="4526aqqn2smop4qe2caq943ln3">&nbsp;&nbsp;&nbsp;&nbsp;环绕通知必须有返回值，即目标方法的返回值</a>
</h3>
<h3 class="topic">
<a name="059fsjjp2eq67k1usgsfovu33o">&nbsp;&nbsp;&nbsp;这些注解下的方法可以传一个参数JoinPoint得到执行的方法的具体信息</a>
</h3>
<h3 class="topic">
<a name="4senp2d3a64dp9b5fjlffn9d5d">&nbsp;&nbsp;&nbsp;切面的优先级，对同一个目标方法，谁先执行</a>
</h3>
<h3 class="topic">
<a name="054t6po48oen41nbhle3vrbmlf">&nbsp;&nbsp;&nbsp;&nbsp;@Order（Int）</a>
</h3>
<h3 class="topic">
<a name="31l1jojos58vem3rh9l999tvtk">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值越小优先级越高</a>
</h3>
<h3 class="topic">
<a name="2msqlm5plf5r8kvqgknps450fc">&nbsp;springboot自动配置原理</a>
</h3>
<h3 class="topic">
<a name="5fmo0ruk97hv45kbgr8mv9mbg4">&nbsp;&nbsp;https://www.cnblogs.com/lfjjava/p/6096884.html</a>
</h3>
<h3 class="topic">
<a name="6ptuqvv5lk3q7tp2ea3bi1dfhu">&nbsp;springMVC原理</a>
</h3>
<h3 class="topic">
<a name="5hmud6i1gutm5n3jufvevi5e4h">&nbsp;&nbsp;https://www.cnblogs.com/xiaoxi/p/6164383.html</a>
</h3>
<h3 class="topic">
<a name="2edt6t3ia7ivtls2j3ub06rdbs">&nbsp;&nbsp;https://images2015.cnblogs.com/blog/249993/201612/249993-20161212142542042-2117679195.jpg</a>
</h3>
<h3 class="topic">
<a name="27g37i4n38vfm5a210iv61ipp5">&nbsp;springboot如何修改默认配置</a>
</h3>
<h3 class="topic">
<a name="2a3uak0c0vel5h45bgkaehc7ie">&nbsp;&nbsp;https://blog.csdn.net/qq_42402854/article/details/90603103</a>
</h3>
<h3 class="topic">
<a name="0sbusq9lesfi5jadie2g5cfuvb">&nbsp;spring对事务的支持</a>
</h3>
<h3 class="topic">
<a name="5fphmpob5voklnmbcl6lqnimak">&nbsp;&nbsp;声明式事务</a>
</h3>
<h3 class="topic">
<a name="2nm5210npsl9l1ish2aie66hgl">&nbsp;&nbsp;事务传播行为</a>
</h3>
<h3 class="topic">
<a name="36v1bh48rl3vram2n3e8mnlupg">&nbsp;&nbsp;&nbsp;所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</a>
</h3>
<h3 class="topic">
<a name="4phvqhdhld197d1b1cnp537or5">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</a>
</h3>
<h3 class="topic">
<a name="1qbqen7ck7up5hf0omvptrlurf">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</a>
</h3>
<h3 class="topic">
<a name="56qou5r3nfmuu63mrrvnk74p2c">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</a>
</h3>
<h3 class="topic">
<a name="22gq91li1vtkqlecb2fo74bml6">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</a>
</h3>
<h3 class="topic">
<a name="214ab33d1c0i0kom66la4e4g5n">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</a>
</h3>
<h3 class="topic">
<a name="1p5vbp138mgobvnvjqkqop3969">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</a>
</h3>
<h3 class="topic">
<a name="7j1lj0hefn92ln2elv426ou6hd">&nbsp;&nbsp;&nbsp;TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</a>
</h3>
<h3 class="topic">
<a name="1qv0q1r6fhdphofor6tb8h9s04">&nbsp;&nbsp;设置隔离级别</a>
</h3>
<h3 class="topic">
<a name="4m08s1dnm79od2a6493mvg6vue">&nbsp;&nbsp;事务超时</a>
</h3>
<h3 class="topic">
<a name="0hejckcq5amnnklv1chrfvqejr">&nbsp;&nbsp;&nbsp;所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</a>
</h3>
<h3 class="topic">
<a name="7hhb78nb8p7jq2f5od6nhg19bk">&nbsp;&nbsp;&nbsp;  默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</a>
</h3>
<h3 class="topic">
<a name="640d1iirmnanasuipa5315itkv">&nbsp;&nbsp;事务只读属性</a>
</h3>
<h3 class="topic">
<a name="60smhftvakd59ckf60vfjnqmu9">&nbsp;&nbsp;&nbsp;只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。</a>
</h3>
<h3 class="topic">
<a name="1avvfvvcm53eij4akbnabniocg">&nbsp;&nbsp;&nbsp;默认为读写事务。</a>
</h3>
<h3 class="topic">
<a name="0lr3a6r2p6e77m6d83am05uvin">&nbsp;&nbsp;&nbsp;        &ldquo;只读事务&rdquo;并不是一个强制选项，它只是一个&ldquo;暗示&rdquo;，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。 </a>
</h3>
<h3 class="topic">
<a name="6k47e30u16i77qvhj6j93iglsg">&nbsp;&nbsp;&nbsp;但是你非要在&ldquo;只读事务&rdquo;里面修改数据，也并非不可以，只不过对于数据一致性的保护不像&ldquo;读写事务&rdquo;那样保险而已。 </a>
</h3>
<h3 class="topic">
<a name="628ovc4vjln0p4tre1ejib7j3r">&nbsp;&nbsp;&nbsp;因此，&ldquo;只读事务&rdquo;仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可</a>
</h3>
<h3 class="topic">
<a name="763bjv3mfpee2gdp91q5sa55jp">&nbsp;&nbsp;spring事务回滚规则</a>
</h3>
<h3 class="topic">
<a name="3knjqre48irsgdveo2fmgv7snk">&nbsp;&nbsp;&nbsp;指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。</a>
</h3>
<h3 class="topic">
<a name="4jn59u6ah8ql6j6flnfnmqnjs5">&nbsp;&nbsp;&nbsp;        默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。</a>
</h3>
<h3 class="topic">
<a name="0fbgdh5spfc7emltqognbiu695">&nbsp;springboot对springMVC的自动配置以及如何定制自己需要的配置</a>
</h3>
<h3 class="topic">
<a name="61k3giicnlq23j8nmk79jrifss">&nbsp;&nbsp;https://www.jianshu.com/p/014086358097</a>
</h3>
<h3 class="topic">
<a name="3n4lahj27b0d47lemjhegnprkb">&nbsp;&nbsp;自动配置</a>
</h3>
<h3 class="topic">
<a name="2toida8o4qoqq7ran37fpamvcm">&nbsp;&nbsp;&nbsp;1.Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.&#13;
包含 ContentNegotiatingViewResolver 和 BeanNameViewResolver 组件(beans)&#13;
&#13;
ContentNegotiatingViewResolver 从后缀(ViewResolver)可以看出是一个视图解析器&#13;
ContentNegotiatingViewResolver 这个组件的作用是,根据方法返回的值得到视图对象(View)&#13;
然后视图对象决定如何去工作,比如重定向还是什么的.&#13;
可以看在WebMvcAutoConfiguration类,看看源代码是怎么写的&#13;
</a>
</h3>
<h3 class="topic">
<a name="4o03rhultsa13gv9ma45bh04ce">&nbsp;&nbsp;&nbsp;2.Support for serving static resources, including support for WebJars (covered later in this document)).&#13;
提供了静态资源的支持包括WebJars</a>
</h3>
<h3 class="topic">
<a name="7fr3t60sljg5lqulngvkfg395n">&nbsp;&nbsp;&nbsp;3.Automatic registration of Converter, GenericConverter, and Formatter beans.&#13;
自动注册了 Converter(转换器),GenericConverter,Formatter组件(bean)&#13;
&#13;
转换器的介绍可以去看看springmvc官方&#13;
Converter : springmvc 类型转换是使用了Converter,客户端传一个true的话,是需要Converter转换为布尔类型的1&#13;
Formatter : 客户端传一个2018-05-15的字符串过来,需要Formatter来格式化成一个Date类</a>
</h3>
<h3 class="topic">
<a name="6h6hd8sch4lmlso2bqjvdog8mc">&nbsp;&nbsp;&nbsp;4.Support for HttpMessageConverters (covered later in this document).&#13;
&#13;
支持HttpMessageConverters HTTP消息转换器,如果方法里面返回一个User对象,就需要有一个转换器来将对象序列化成JSON&#13;
HttpMessageConverters也是一个配置类,详情可以去看看源代码&#13;
HttpMessageConverters也是从IOC容器中确定使用哪个HttpMessageConverters.&#13;
也可以添加自己的HttpMessageConverters,只需要添加进IOC容器就好&#13;
可以看看官方的demo,我也截图了官网的demo</a>
</h3>
<h3 class="topic">
<a name="3knb3bju0398tvghi9sn7sbokn">&nbsp;&nbsp;&nbsp;5.Automatic registration of MessageCodesResolver&#13;
自动注册MessageCodesResolver ,就是支持MessageCodesResolver.</a>
</h3>
<h3 class="topic">
<a name="0b23lrbm0o10693auvp38l64b8">&nbsp;&nbsp;&nbsp;6.Static index.html support. 静态首页访问</a>
</h3>
<h3 class="topic">
<a name="41u9bu3e1b5k8dmrep3hjfit81">&nbsp;&nbsp;&nbsp;7.Automatic use of a ConfigurableWebBindingInitializer bean&#13;
注册使用ConfigurableWebBindingInitializer 组件&#13;
&#13;
ConfigurableWebBindingInitializer是什么东西? 可以从命名中猜一下&#13;
WebBindingInitializer 是 绑定请求数据&#13;
客户端传一个 url?username=Elson&amp;age=27 可以绑定到对应的User类中.&#13;
也就是springmvc的数据双向绑定&#13;
可以自定义配置ConfigurableWebBindingInitializer来替换SprintBoot默认的</a>
</h3>
<h3 class="topic">
<a name="5irs0sqq4uo1920e9e3b7psgdk">&nbsp;&nbsp;&nbsp;8.Custom Favicon support </a>
</h3>
<h3 class="topic">
<a name="78rs8irip5t20p45nioei0lvec">&nbsp;&nbsp;如何定制</a>
</h3>
<h3 class="topic">
<a name="5n5a62pu698igr6gvl5jj4a9ch">&nbsp;&nbsp;&nbsp;HttpMessageConverters</a>
</h3>
<h3 class="topic">
<a name="1f22cu1rbda34ivvihrv93167v">&nbsp;&nbsp;&nbsp;&nbsp;@Configuration&#13;
public class MyConfiguration {&#13;
	@Bean&#13;
	public HttpMessageConverters customConverters() {&#13;
		HttpMessageConverter&lt;?&gt; additional = ...&#13;
		HttpMessageConverter&lt;?&gt; another = ...&#13;
		return new HttpMessageConverters(additional, another);&#13;
	}&#13;
}</a>
</h3>
<h3 class="topic">
<a name="0hpqiv4f7d6g4bvtvj9qp1r4da">&nbsp;&nbsp;&nbsp;视图映射</a>
</h3>
<h3 class="topic">
<a name="2ua1mj9f7qqre4923rjjij12b7">&nbsp;&nbsp;&nbsp;错误页面定制</a>
</h3>
<h3 class="topic">
<a name="45rvdh9c5h9kf5aftsfmud2cns">&nbsp;&nbsp;&nbsp;拦截器</a>
</h3>
<h3 class="topic">
<a name="09q4iaf9930a68ffo8hho1stdm">&nbsp;&nbsp;&nbsp;静态资源</a>
</h3>
<h2 class="topic">
<a name="3ep6odheu3ksjcbro3gf7g2re4">自由主题</a>
</h2>
</body>
</html>
